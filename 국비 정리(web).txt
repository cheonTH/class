<html> ... </>: 루트요소
<head> ... </>: 메타데이터나 제목이 들어가는 요소
<title> ... </>: 웹 페이지의 제목/ 상단의 탭에 적용됨
<body> ... </>: 웹 페이지에 실질적으로 내용이 보이게하는 부분의 요소
<link>: 외부파일을 현재 웹 문서에서 사용하려고 할 때 연결하는 태그
<br>: 줄바꿈을 담당하는 태그
<p> ... </>: 단락 구분 block속성(태그가 끝나면 알아서 줄바꿈이 됨)을 가지고 있다.
<h1~6> ... </>: 제목 부제목 소제목을 작성할때 사용하는 태그(1이 제일 크고 6일 제일 작음) 절대 글씨를 두껍게하는 용도로 사용X
<strong> ... </>: 글씨를 두껍게 만들어 강조하는 역할 <b>보다 더 중요한 글씨 강조때 사용
<b> ... </>:글씨를 두껍게 만드는 역할
<button> ... </>: 버튼을 생성하는 태그
<div> ... </>: 영역을 나누는 태그/ 비슷한 요소들끼리 묶는 태그
<input>: 입력을 받는 태그
<hr> 가로선을 만드는 태그
<textarea rows = "" cols = ""> ... </>
<select> ... </>: 드롭다운 메뉴
ㄴ<option> .. </>: 드롭다운에 들어있는 메뉴
<table> ... </>: 테이블을 만들어주는 태그
ㄴ<tr> .. </>: 행을 생성하는 태그
ㄴ<td> .. </>: 열을 생성하는 태그
ㄴ<th> .. </>: 제목을 생성하는 태그 td랑 비슷
ㄴ<thead> .. </>: 헤더 그룹
ㄴ<tbody> .. </>: 바디 그룹
ㄴ<tfoot> .. </>: 푸터 그룹
<ul> .. </>: 순서가 없는 리스트
<ol> .. </>순서가 있는 리스트
<del> .. </>: 취소선
<sub> .. </>: 아래 참조
<sup> .. </>:윗 참조
<em>, <i>  .. </>: 이텔릭체로 글씨가 기울어서 써짐
<iframe> .. </>:외부 URL, 동영상, 내부 문서를 불러와 현재 페이지에 작성 가능
<audio> .. </>: 음성파일 재생 가능
<video> .. </>: 영상파일 재생 가능

<herf> 링크 이동 <a> ... </>와 사용
<src> 이미지 경로 지정 - alt 이미지 대체 문구(이미지가 노출이 되지 않는 경우 대체 노출되는 문구)
&nbsp; -> 띄어쓰기

공식적으로 정해진 속성이 아니라 내가 넣고싶은 데이터를 태그에 삽입할 때 사용하는 것이 '데이터 셋 속성'

어떤 태그를 사용했을때 다음 요소가 아래 나오는 경우 => block속성을 가지고 있을 확률 높은 (block특성이 없다면 바로 옆에 나옴)

메타 정보: 데이터에 대한 데이터 (Ex. 동영상 파일에서의 인코딩 타입 등)

내용(content)
열린 태그와 닫힌 태그 안에 둘러싸인 문자열

엘리먼트(elenent)
태그와 내용을 합친 형태

html은 작성하면 위에서부터 아래로 요소들이 보여짐

속성(attribute)
시작태그 안에서 사용되며 기능 설정 사항을 지시
추가적인 정보를 제공

<태그명(tag) 속성(attribute)="값(value)">내용</태그명(tag)>

속성 Ex) <a> ... </a>에 들어가는 herf(이동할 페이지의 링크를 지정하는 속성) => <a herf=""> ... </a>
           <img>에 들어가는 src(이미지의 경로를 지정), width(요소의 너비), height(요소의 높이), alt(이미지가 출력되지 않을때 대신 나올 문구) => <img src="">
           style: 요소에 직접 디자인을 설정 할 수 있음

커스텀 사용자 속성: 고유한 값을 저장할 수 있음
=> 사용방법: data-속성명="값"

CSS
CSS 적용 방식
CSS를 HTML 파일에 어떻게 적용 시키나?
1. 인라인 방식(태그에 직접 적용) : html의 각 태그에서 style속성에 직접 작성하는 방식
Ex) <h2 style ="color: red">인라인 적용</h2>
2. 내장 방식(embedded 방식)
<header>
	<style>
		h2{color: "red";}
	</style>
</header>
3. 링크 방식(link): 외부의 CSS파일을 불러와서 적용
<link rel = "stylesheet" type = "text/css" href = 'css 외부 파일 경로>
4. @import방식
@import url(css/style.css);

HTML 요소를 선택하는 방법
선택자
CSS를 누구한테 적용시킬것인가?
1. 태그를 직접 선택 -> 문서에 해당 태그의 디자인이 전부다 바뀜 / 단점: 원하는 것만 바꿀 수 없음
2. 클래스 선택자: HTML에서의 클래스 -> 특정 집단을 묶는 것
2-1. 태그에 클래스명을 붙인다.
ㄴ<태그명 class="클래스명">content</태그명> 
2-2. 클래스를 붙인 태그를 선택함
ㄴ .클래스명{선언; 선언;}

CSS 문법
셀렉터(태그, 클래스명, id) 선언 블록({프로퍼티(속성): 값;})

selector: css를 적용하고자 하는 HTML 요소
선언부: 하나 이상의 선언들을 세미콜론으로 구분하여 포함, 중괄호를 사용하여 전체를 둘러쌈
ㄴ각 선언은 속성명과 속성값을 가짐, 그 둘은 콜론으로 연결 됨
ㄴ언제나 마지막에 세미콜론으로 끝

*{color: ~~}: 모든 요소
div *{color:~~}: div 안의 모든요소

스타일 적용시키기
1. 스타일을 적용시킬 태그를 선택
ㄴ> 태그, 클래스, 아이디
2. 스타일을 적용
ㄴ> 인라인, 임베디드 방식, 외부에서 불러옴

테두리
border-width: 두께
border-style: 스타일
border-color: 색깔
border: 두께, 스타일, 색깔

여백
padding: 내용과 테두리 사이의 여백
margin: 요소와 외부사이의 여백

폰트
font-size: 폰트 크기
font-weight: 폰트 두께
font-style: 기울기
font-family: 폰트 선택
font: weight, style, size, family 순으로 적용해야 함

이미지 배경넣기
{background: url(경로)}
ㄴ> no-repeat
ㄴ> repeat-x
ㄴ> repeat-y

로렘입숨(Lorem Ipsum): 

flex의 container속성
justify-content: 메인 축을 기준으로 수평에서의 정렬
align-content: 메인 축을 기준으로 수직에서의 정렬

CSS파일을 분리하는 이유
1. HTML코드 내부에서 디자인과 관련된 요소를 제거할 수 있기 때문
-> HTML코드가 정보의 전달과 웹 페이지의 구조 설계라는 본연의 기능에 집중할 수 있게 됨
2. 협업의 편의성
-> 웹 페이지의 기능적 측면에만 집중할 수 있다는 장점이 있음

미디어쿼리
@midea(조건){조건이 맞을때 보여줄 스타일}

★grid: 표 형태로 배치(행과 열을 정해야 함)
ㄴgrid-template-rows(행의 배치)  px, fr(비율)
ㄴgrid-template-columns(열의 배치)
ㄴrepeat(반복횟수, 반복값)
ㄴEx. repeat(5, 1fr) -> 1fr 1fr 1fr 1fr 1fr
ㄴEx2. repeat(3, 1fr 4fr 2fr) -> 1fr 4fr 2fr 1fr 4fr 2fr 1fr 4fr 2fr
ㄴ grid-template-rows : repeat(3, 1fr)

minmax(): 최소값과 최대값을 지정할 수 있는 함수
ㄴEx. minmax(100, auto) -> 최소는 100 최대는 자동으로 지정

gap: 요소사이의 간격

★flex: 축을 기준으로 배치(수직 또는 수평으로 메인축을 정해야함)
ㄴ컨테이너에 주는 속성
-justift-content: 메인축 기준 아이템 정렬 방법
-align-items: 반대축 기준으로 아이템 정렬 방법
-flex-direction: 메인 축 결성
ㄴ아이템에 주는 속성
-order
-flex-grow
-flex-shrink
-flex

<<Java Script>>
<head>에 <script>태그 넣기
-HTML문서가 실행되는 동안 로딩이되며, 페이지의 렌더링을 차단할 수 있음.
-자원 초기화(init) 및 설정: 웹 페이지의 초기화 및 설정과 관련된 코드들을 넣음

<body>에 <script> 태그 넣기
-페이지의 렌더링이 진행되는 중에 로드되기 때문에 페이지의 다른 내용들은 먼저 로드되고 렌더링이 됨
-동적 작업 및 이벤트 처리: 동적으로 생성되는 컨텐츠나 이벤트 처리와 관련된 스크립트를 위치시킴
-미리 넣어야하는 내용을 <head>에 나머지는 <body>에 위치 시키는 것이 일반적인 방법

프로그램의 구성
데이터(data)와 명령어(instruction)의 결합으로 구성

데이터 
-실질적인 값
-숫자, 문자와 같은 단순한 데이터부터 사진, 영상, 음성과 같은 복합적인 데이터가 있음
-데이터는 언제든지 수정할 수 있어야 하며 사용목적에 따라 다른 형태로 가공할 수 있어야 함
-이러한 데이터는 컴퓨터의 메모리에 저장됨

자료형(data type)
숫자(number) - 1, 5 ,100, 3.14, 1.23    .....
문자(character) - a, c, z, f, 홍길동, 안녕하세요   .....
논리형(boolean) - 참(true), 거짓(false)

변수(variable)
-데이터를 저장하고 조작하기 위한 이름이 붙은 메모리 공간
var: 같은 이름의 변수가 만들어졌을 때 감지를 못한다.(에러가 안난다)
let: 같은 이름의 변수가 만들어졌을 때 감지한다.(에러가 난다)
ㄴ> 새로운 값은 대입할 수 있음.
const: 같은 이름의 변수가 만들어졌을 때 (에러가 난다.) // 대입이 불가능함

변수명 짓는 규칙
1. 첫글자로 영문자(a~z, A~Z), 밑줄(_), 달러기호($)로 시작해야함 숫자X
2. 대소문자를 구별(home과 Home은 다른 변수로 인식)
3. 공백이나 특수문자를 포함할 수 없음
4. 예약어 사용 불가(if, for, while 등) 자바스크립트에서 이미 사용중인 예약어는 변수명으로 사용할 수 없음
5. 한글 절대 사용 X (변수명, 폴더 이름, 파일 이름 등등)
6. 데이터와 관련된 이름으로 지으면 좋음

변수명 표기법
camel Case(낙타표기법)
첫 단어는 소문자로 시작하고 다음단어부터는 대문자로 시작
Ex) homeAddress, totalScore,myAge

snake_case(스네이크 표기법)
단어 사이에 밑줄(_)로 연결하는 규칙
Ex) home_adress, total_score, my_age

Pascal Case(파스칼 표기법)
모든단어의 첫 글자를 대문자로 작성
Ex) HomeAddress, TotalScore, MyAge

헝가리 표기법
변수명을 지을 때 데이터의 타입이나 의미를 나타내는 접두사를 붙임
Ex) age -> n(number)Age, count -> nCount, date -> sDate


컴퓨터 하드웨어
영구 기억장치 -> HDD, SDD -> 껐다 켜도 데이터 보존
임시 기억장치 -> RAM -> 껐다 켜면 초기화

-데이터(물)를 담는 그릇(변수)이다.

연산자(operator)
연산자: 기능이 있는 기호
피연산자: 연산을 당하는 쪽

산술연산자
- 더하기(+), 빼기(-), 곱하기(*), 나누기(/), 나머지(%)

1. HTML 작성
2. CSS 
ㄴ 스타일을 적용할 태그먼저 선택
ㄴ 적용
3. JS코드 작성
ㄴ 제어할 태그먼저 선택 document.queryselector()
ㄴ 선택한 태그 제어

restful하게 만든다
http request method
서버 구조에서 요청(request)과 응답(response)이 이루어지는 방식을 의미

<<method 속성>>

GET: 조회 메서드
- 특정 조건을 전달하고 싶으면 쿼리스트링()으로 전달

쿼리스트링 : 사용자가 입력데이터를 전달하는 방법 중 하나
URL 뒤에 물음표와 KEY = VALUE&KEY = VALUE를 덧붙여서 추가적인 정보를 서버측에 전달

POST : 전달한 데이터를 처리/ 추가하는 메서드
- 주로 신규 리소스 등록, 프로세스 처리에 사용 , 바디에서 직접 적용(아이디, 비밀번호 만들 때 유용)

PUT : 리소스를 대체(수정)하는 메서드
- 요청 메시지에 리소스가 있으면 덮어쓰고 없으면 새로 생성함

PATCH : 리소스의 일부분을 변경하는 메서드

DELETE : 리소스를 제거하는 메서드

this : 자기 자신에 대한 참조
-메서드 안에서의 this
ㄴ>메서드를 소유한 객체를 참조
객체 안에서는 일반적인 모양의 함수는 인식
화살표 함수는 내부에서 사용하는 this는 함수를 포함하고있는 객체를 참조하지 못함

DOMContentLoaded
동기방식 -> 하나의 명령이 끝나느 대로 다음 명령을 수행
HTML요소가 만들어지지 않은 상태에서 기능 추가 명령을 하니 에러가 발생
순차적으로 실행 되므로 꼬이는 문제가 발생

비동기 방식 -> 당장 처리해야할 명령과 나중에 처리해야할 명령을 구분할 수 있음

★배포(deploy)
html,css,js -> 자신의 컴퓨터에서만 볼 수 있음(로컬 환경)

배포 - 웹페이지를 인터넷과 연결하여 누구나 접속해 볼 수 있는 상태로 만드는 행위
웹 페이지 배포절차
1. 웹 페이지를 컴퓨터에 저장
2. 컴퓨터를 인터넷이 연결
3. 컴퓨터의 설정을 변경하여 외부에서 접속할 수 있도록 함
4. 외부인이 접속을 요청을 할 때마다 컴퓨터가 웹 페이지를 보여줌

이때 사용된 컴퓨터를 서버(server)라고 부름

웹 호스팅 서비스
서버 용도로 사용되는 컴퓨터는 일반 컴퓨터보다 비쌈
인터넷 회선도 무료가 아님

서버를 많이 구매한 후 인터넷 회선에 가입 후 서버를 빌려주는 회사들이 존재
이러한 서비스를 웹 호스팅이라 부름

서버 컴퓨터는 사양이 매우 높기때문에 하나의 서버에서 홈페이지를 수십~수백개까지 운영 가능
cafe24, 가비아 등

github페이지 - 깃허브에서는 무료로 웹페이지를 호스팅할 수 있는 서비스를 제공
레포지토리로 이동 -> settings -> 왼쪽 메뉴에 pages -> branch에 master or main설정

주의해야 할 점
root폴더에 index.html이 존재해야함

지킬
프레임워크

지킬-생태계(eco-system)
생태계라고 부를만큼 다양한 사용자들이 존재
지킬로 만든 자기 작품을 많이 공유함

MIT라이센스
이 소프트웨어를 누구든지 무상으로 제한없이 사용하되 완성된 소프트웨어의 중요한 부분에 저작권 표시를 해야함
소프트웨어의 원작자는 아무런 책임을 지지않음

레포지토리의 포크
레포지토리의 복제본을 만드는 방식중 하나
원본 레포지토리의 내용이 수정되거나 삭제되더라도 현재의 버전을 간직해두고 사용할 수 있음
현재 버전의 레포지토리를 박제하는 행위

템플릿의 이해
우리가 가져온 템플릿의 HTML, CSS, JS를 건드릴 필요 없이 내용정도만 수정을 하면 됨

git
git init ->해당폴더를 git이 관리
git remote add 레포url -> 원격으로 repo와 연결
git add . -> 해당폴더에 있는 파일을 stage에 올림
git commit -m init -> git이 관리하도록
git push origin master

jekyll 삭제하는 법

gem uninstall jekyll

gem install jekyll -v '4.3.3 -> 특정버전을 다운로드 받을 수 있음

_data파일 -> 웹사이트에서 활용할 데이터를 저장할 수 있음
_includes -> 웹 페이지에 포함시킬 html파일 저장
_layout -> 웹 페이지의 뼈대를 결정 html파일들
_posts -> 블로그 게시글을 저장
_sass -> css의 기능을 확장시켜 더 효율적이고 유지보수하기 쉬운 스타일시트를 작성할 수 있도록 도와줌
_site -> 빌드가 끝난 코드가 저장됨

코드를 다 작성하고 마지막에 빌드라는 작업을 통해 데이터가 조립되어 배포에 적합한 상태로 다듬어짐

실제로 배포할 때는 빌드된 코드만 사용함

배포(deploy) : 내가 만든 웹 페이지를 외부에서도 접근할 수 있도록 하는 행위

내 컴퓨터로 배포 가능
웹 서버(web server) : 아파치, nginx 등...
웹 호스팅 서비스 : 서버를 빌려주는 것 -> cafe24, 가비아 등...

서버(server) : 서비스를 제공하는 주체

클라이언트(client) : 서비스를 이용하는 사람들

프레임워크 : 기본적인 뼈대는 준비가 되어있고 내 입맛에 맞게 수정할 수 있음

ruby -> jekyll
js -> express
java -> spring
python -> django,flask
c# -> .NET


-forEach()
let numbers = [1, 2, 3, 4, 5]
기존
for(let i = 0; i< nuumbers.leangth; i++){
	console.log(numbers[i]
}
numbers.forEach((x) => console.log(x));

게시판에 OR 상품 데이터를 나열할 때 사용

정규 표현식
문자열에서 특정 패턴을 찾거나 일치 여부를 확인, 변경할 때 사용하는 도구

[   ]: 괄호안의 조건에 맞는 문자 1개
[a-z] : a ~ z까지 소문자
[A-Z] : A~Z까지 대문자
[0-9] : 숫자 0~9까지

\d: 0~9
\D: 숫자가 아닌 것
\w:  영문자, 숫자, _
\W: \w이외의 문자

/ ... /

반복 패턴
* 0회 이상 반복
+ 1회 이상 반복
? 0 또는 1회
{n} n번 반복
{n,} n번 이상 반복
{n,m} n~m번 반복

위치 패턴
^: 문자열의 시작
$: 문자열의 끝

[\w.-] : 영문자, 숫자, _,.,- 중에 1글자 나올 수 있음
[\w.-]+ : 영문자 숫자 점 하이픈 중 하나 이상의 문자로 이루어진 문자열

이메일Ex)
/[\w.-]+ @ [\w.-] \.\w+ /

phone
/^010 - [0-9]{4} - [0-9]{4}$/

주민등록번호 정규식
/^\d{6} - \d{7}$/ ==> 유효성 체크를 하지 않을 때
/^([0-9{2})(0[1-9] | 1[0-2])(0[1-9] | [12][0-9] | 3[01] - [1-4][0-9]{6}$/    //[12] => 1~2 , [01] => 0~1