프로젝트 구성요소
package.json
프로젝트의 메타 데이터
사용할 node.js의 패키지 목록
버전도 명시가 되어있음
필요한 패키지가 있다면 package.json의 dependencies에 명시하고 npm install을 하면 node_modules에 설치됨

package-lock.json
어느 환경에서든 같은 버전의 패키지를 설치하기 위해 각 패키지가 사용할 버전을 고정해놓음
보통 이 작업은 npm install 또는 create-react-app명령시 자동으로 실행됨

Hook
리엑트에서 제공하는 메서드
리엑트 초반 함수형 컴포넌트는 단순한 UI그리기만 가능하고 상태에 대한 관리를 할 수 없었음
함수형 컴포넌트에서 상태와 생명주기를 사용할 수 있게 해주는 기능

Hook의 역할
상태관리와 사이드 이펙트 로직을 함수 단위로 재사용할 수 있게 하고, 클래스 없이도 복잡한 로직을 깔끔하게 작성하도록 도음

상태(state)
컴포넌트 내부에서 변경 가능한 데이터
state가 바뀌면 해당 컴포넌트가 다시 렌더링되어 화면에 변경된 내용을 반영함

state를 생성하는 법
userState()라는 훅을 사용해야함
컴포넌트 내부에서 state를 선언하고 변경할 때 사용하는 훅

useState훅이 실행이 되면 state 하나와 state의 값을 변경할 수 있는 setter 함수가 요소로 있는 배열을 반환

useState(): 상태를 관리하는 Hook의 일종
메서드를 호출하고 상태변수와 상태변수의 값을 바꿀 수 있는 setter 하나를 돌려줌

const[변수명, 함수명] = useState(초기값)
초기값 자리에 기본자료형, 배열, 객체도 가능

왜 useState()가 제공하는 setter함수를 실행했을 때 자동으로 화면이 렌더링 되는가?
1. setter함수를 호출하면 상태가 바뀌었다는 사실을 react에 알림 이 컴포넌트를 재렌더링해야한다고 예약함
   예약된 업데이트 시점에 react는 해당 컴포넌트를 다시 호출해 JSX를 살펴봄
   이전 렌더 때와 달리 바뀐값을 반환하므로 JSX의 결과가 달리질 수 있음 


Props
컴포넌트에 데이터를 전달하는 방식
외부로 부터 값을 받아서 렌더링하거나 동작할 수 있음
props라는 이름의 자바스크립트 객체임

기본적으로 props로 넘어온 데이터들은 읽기전용이지만
수정하고 싶다면 state를 이용해서 바꾸면 됨

변수(state)의 값이 변했을 때 새로고침을 안해도 바뀌는 이유
ㄴ> 상태를 변경하는 setter함수를 호출하면 새로운 상태 값 또는 상태 업데이트 요청이 React의 상태 큐에 추가됨
      React는 큐(줄(line))를 처리하여 상태 변경 요청을 실제상태에 반영함
      이 과정에서 React는 비동기적으로 상태를 업데이트하므로 여러상태 변경이 있을 때 효율적으로 처리할 수 있음

HTML + CSS,JS -> 매 페이지를 다 만들어야 함
React -> 페이지 하나를 두고 요소만 바꿔끼우는 형태
SPA(Single Page Application) < - > MPA(Multi Page Application)

브라우저가 화면을 렌더링하는 방식
서버에 요청을 하고 화면을 돌려받음
브라우저는 DOM트리를 만들고, CSSOM트리를 만듬
두개를 합쳐서 RENDER트리를 만들고 RENDER트리를 기반으로 브라우저에 요소들을 배치함

렌더링 방식
클라이언트 사이드 렌더링(CSR)
ㄴ> 클라이언트쪽에서 HTML,JS를 받아서 브라우저쪽에서 렌더링
ㄴ> 초기 로딩 속도가 느림
ㄴ> 초기 로딩 후 필요한 데이터만 서버에서 가져와 동적으로 업데이트하기 때문에 추가 페이지 로딩이 없음
ㄴ> 전체 페이지를 매번 새로 렌더링하지 않고 변화가 있는 부분만 업데이트하므로 서버에 부담을 덜어줌

서버 사이드 렌더링(SSR)
ㄴ> 웹 페이지를 렌더링을 시켜서 클라이언트한테 보냄
ㄴ> 초기 로딩이 빠름
ㄴ> 서버에 대한 부하가 커질 수 있음


리엑트는 페이스북에서 만든 자바스크립트 라이브러리
SPA나 모바일 어플리케이션의 개발 토대로 사용이 됨

컴포넌트 기반의 구조
- 컴포넌트 : UI를 구성하는 독립적인 단위

컴포넌트의 특징
- UI조각
- HTML의 특정부분을 정의할 수 있음
- 버튼, 입력 필드, 다이얼로그와 같은 다양한 UI요소를 컴포넌트로 만들 수 있음

재사용성
- 컴포넌트는 재사용이 가능
- 같은 코드를 여러번 쓰지 않아도 됨

독립성
- 컴포넌트는 독립적으로 동작할 수 있음
- 어플리케이션의 복잡한 UI를 작은 조각으로 나눠서 관리할 수 있음

모든 컴포넌트는 함수로 관리

function 컴포넌트명() {
	return(HTML 코드)
}
컴포넌트명은 첫글자를 대문자로 씀

JSX(JavaScript Xml)
자바스크립트 안에 HTML처럼 UI구조를 작성할 수 있게 해주는 문법

const element = <div className = "container">Hello</div>

표현식의 삽입
중괄호{}안에 임의의 JS표현식을 넣어 결과를 렌더링할 수 있음

const name = '홍길동';
const element = <h1>안녕, {name}님</h1>

{isLoggedIn ? <Dashboard/> : <LoginForm/>}

앞의 조건이 참이면 컴포넌트를 렌더링함
거짓이면 안함
{item.length > 0 && <ItemList item = {items/>}

배열에 있는 내용을 꺼내서 화면에 렌더링을 해야함
{todos.map(todo => (
	<div>
		
	</div>

리엑트에서 매개변수 -> props
리엑트에서 생명주기를 관리하는 변수 -> state

생명주기 -> 언제 메모리에 올라가서 언제 없어지는가



react는 key속성에 들어있는 값을 참조해서, 리스트의 요소가 변경될 경우 어떤 요소가 변경되었는지 빠르게 파악할 수 있음

Paper 컴포넌트
종이같은 표면 효과를 제공하는 컨테이너 컴포넌트
elevation(그림자 깊이)를 통해 높낮이를 표현하고 배경색과 그림자 효과로 컨텐츠를 돋보이게 함

items(객체명).length : 배열에 내용이 있을 때만 렌더링

JSX는 표현식이기 때문에 if, for, 매개변수로 전달, 반환할 수 있음