React
컴포넌트를 기반으로 하는 자바스크립트 라이브러리
node가 설치되어있어야 함 -> npm을 사용하기 위함



npm init -> 폴더를 npm으로 초기화를 하겠다는 뜻
여러가지 설정을 해줘야함
패키지 이름,  초기버전, 프로젝트 설명 등등...



package.json
프로젝트에 대한 메타데이터 정보가 들어있음 -> 명세서 같은 느낌..




npm install react -> react 설치 



npm install -> package.json을 읽어가지고 다운로드를 받음
<https://registry.npmjs.org>(npm istall로 접근 했을 때 방식)<npmjs.org>(일반적인 방식??)로 요청을 보냄
설치하려는 패키지의 메타데이터(버전, 의존성 정보)를 조회
실제 압축된 파일을 내려받음



 == react 쉽게 설치 ==
npx create-react-app : 기본적으로 필요한 파일들을 가진채로 시작

react는 index.html 파일 하나만 가지고 있음
index.html은 <div id = "root"></div> 요소 하나만 가지고 있음

index.js에서 <div>요소를 react의 루트요소로 만듬

render()메서드를 이용해 컴포넌트를 렌더링함



컴포넌트를 만들 때는 함수로 만듬
컴포넌트 이름을 지을 때는 첫글자는 대문자로 만듬
컴포넌트를 다 작성하면 외부에서 사용하기 위해 export를 해줘야함 
export default  컴포넌트명; => 모듈(하나의 파일)당 하나
export {컴포넌트명, 컴포넌트명 ...};  => 여러개를 export하는 것이 가능
컴포넌트의 호출 => import
default로 내보낸 것 -> 중괄호 없이 원하는 이름으로 쓸 수 있음
그냥 내보낸 것 -> 무조건 중괄호 써야함, 이름을 그대로 써야함

function 컴포넌트명(props){
	기능
	return(
		html 인터페이스
	)
}



let 컴포넌트명 = () => {} 

JSX문법
JavaScriptXML
react 컴포넌트의 ui부분을 선언적으로 작성하는 문법
JSX는 표현식이기 때문에 if, for, 매개변수로 전달, 반환할 수 있음

장점
- UI구조가 꽤 직관적
- JS표현식을 직접 넣을 수 있음
ex) let name = '홍길동'
<h1>이름 {name}</h2>
- 컴포넌트 재사용 및 유지보수성이 향상됨
ex) const element = <h1>hello, jsx</h1>
{element}

속성 설정
class -> className,for -> htmlFor로 표기

스타일
const style = {color : 'red', fontSize : 20}
const element = <p style = {style}>빨간글자</p>

컴포넌트를 호출하는 것도 JSX문법의 일부
태그 이름이 대문자로 시작하면 컴포넌트로 인식

Self-Closing
html
<br>, <img> ...
JSX(항상 닫아줘야함)
<br />, <img /> ...

우리가 호출하는 컴포넌트의 속성들은 전부 매개변수로 넘어감
<MyComponent item = {item} />  => ex) {item : {  }}형식으로 넘어간다고 보면 됨

<MyComponent item = {item} x = "hi"/>

let MyCompoenet (props) =>{
	props.item = 
	props.x =
}

React는 컴포넌트들의 모음



props
컴포넌트에서 매개변수를 의미
인자는 html속성 = 값 형식으로 전달
<컴포넌트명 x = {10} /> //정수를 보내고 싶으면 중괄호를 사용





인라인으로 스타일을 줄 때는 자바스크립트 객체형식으로 줌
const style = {
	backgroundColor : "gray"
	padding : '16px'
	...
}



Hook
사전적인 의미로는 갈고리
함수형 컴포넌트로 넘어오면서 상태관리, 생명주기 등의 react기능을 사용할 수 있게 해주는 메서드

클래스형 컴포넌트 없이도 동일한 기능을 구현할 수 있고 로직 재사용성이 크게 향상된다는 장점이 있음

useState(): 컴포넌트 내 로컬 상태를 선언하고 업데이트 할때 사용

리액트에서는 데이터를 상태(state)로 관리




왜 상태로 따리 관리를 해야하는 이유
사용자의 입력 네트워크 응답 타이머 등으로 값이 바뀔 때도 값의 변화를 화면에 반영을 해야 하기 때문

상태로 관리하지 않으면 값이 바뀌어도 화면에 반영이 안됨
useState()를 실행하고 나면 [상태값, 상태값을 변경하는 함수]가 담긴 배열을 반환함
상태의 생성 => useState()
useState()함수를 실행하고 나면 상태변수, 상태변수의 값을 바꿀 수 있는 배열을 반환

상태가 변경되면 화면에 바로 반영됨
const[상태, 상태변경함수] = useState(초기값)

초기값 자리에 들어갈 수 있는 타입
기본자료형(숫자, 문자열, 논리형, null, undefined), 배열, 객체 함수




스프레드연산자('...')
반복 가능 객체(배열)나 객체의 프로퍼티를 펼친다 라는 의미를 가짐
복사, 병합, 분해등의 작업을 간결하게 해주는 문법

배열에서의 사용법
const arr = [1,2,3];
const arr2 = [...arr];  // arr에 들어있는 [1,2,3]이 복사됨
const arr3 = [...arr,4,5]; // [1,2,3,4,5] 병합
const arr4 = [0,...arr,4]; // [0,1,2,3,4] 중간 삽입

함수 호출시 인수에 전달
function sum (a,b,c){
	return a + b + c;
}

const nums = [1,2,3]
sum(...nums) // a = 1, b = 2, c = 3

객체에서의 사용법
const obj1 = {x:1, y:2};
const obj2 = {...obj1}; // {x:1, y:2}가 들어감 복사
const obj3 = {z:3, ...obj1} // {z:3, x:1, y:2} 병합
const obj4 = {...obj1, y:20} // {x:1, y:20} y가 있으므로 x만 복사됨

자바스크립트 객체 =>  ex) let obj = {x : 10, y : 5}  // obj.x -> 10 // obj.y -> 5

let  props = {x : 10}
let Comp = (props) => {
	props.x  -> 10
}

let Comp = ({x}) => {
	x  -> 10
}

let Comp = ({x , y}) => {
	x  -> 10
	y  -> 5
}

<컴포넌트 명 x = {10} y = {5} />


onChange : 사용자가 키보드를 입력하거나 붙여넣기, 드로그 앤 드롭 등으로 값이 바뀔 때 마다 실행



useState(), 기능을 하는 함수를 App.js에 만드는 이유
전체 Todo리스트는 App.js에서 관리를 하기 때문


컴포넌트의 생명주기
마운트(컴포넌트가 호출되서 화면에 보여질 때 - 최초렌더링)
업데이트(컴폰너트가 재렌더링 될 때)
언마운트(호출되서 종료되고 화면에서 사라질 때)

useEffect(() => {}, [])
컴포넌트에서 부수효과(side effect)를 처리하기 위한 함수
컴포넌트가 렌더링되면 첫번째 인자에 들어있는 함수가 실행됨

의존성 배열
useEffect()의 실행타이밍을 결정
1. 없으면 렌더딩이 될때마다 실행(마운트 + 업데이트)
2. 빈배열 마운트시 한번만 실행
3. 값 명시 Ex) [count, state] 배열안의 값이 바뀔 때 마다 실행



클린업 함수
첫번째 인자에 들어있는 함수의 리턴함수
useEffect(() => {
	const id = setInterval(() => {
		console.log('1초마다 실행')
	}, 1000)
	
	return () => clearInterval(id);  // 클린업함수(언마운트 시점에 호출, 의존성배열에 들어있는 값이 변경되어 사이드이펙트함수가 호출되기 직전)
}, [])


라우터
리액트는 SPA(Single Page Application)라서 하나의 HTML페이지에서 여러 컴포넌트를 교체하는 식으로 동작
여러페이지를 가진 웹사이트처럼 URL에 따라 다른화면을 보여 주고 싶을 수도 있음
사용자가 URL을 변경하거나 네비게이션을 할 때 페이지를 새로 고침하지 않고도 URL에 맞는 컴포넌트를 렌더링 할 수 있도록 해줌

라우터를 쓰는 이유
1. SPA의 특성을 유지
라우터를 사용하면 브라우저의 새로고침 없이도 URL을 변경하고  해당 URL에 맞는 컴포넌트를 렌더링 할 수 있음

2. 페이지 전환시 깜빡임 방지
MPA(Multi Page Application)에서 사용자가 화면을 이동할 때마다 다시 로드하게 되어 깜빡임이 발생함, 라우터는 그런게 없음

3. 브라우저 히스토리 관리
브라우저의 히스토리 api를 사용해서 뒤로가기 앞으로가기 등의 네이게이션 기능을 정상적으로 동작하게 함



라우팅
1. 주소창에 주소를 확인
2. path에서 일치하는 경로를 찾아서 컴포넌트를 렌더링


중첩 라우팅
라우트 안에 다른 다우트를 포함시켜서 공통 레이아웃이나 레이아웃 내 중첩되는 뷰를 쉽게 구성하는 기법


리다이렉션
특정 조건에 따라 사용자를 다른 페이지로 자동 이동시키는 기능
로그인 후 홈페이지로 리다이렉트하거나, 사용자가 존재하지 않는 페이지에 접근할 때 404페이지로 리다이렉트할 수 있음