0리액트 네이티브
리액트 기반의 모바일 어플리케이션 개발 프레임워크
JSX, 컴포넌트 기반
한 번만 작성하면 안드로이드, IOS 둘다 확인 가능

프로젝트를 만들 때는 expo를 활용

npm install -g expo-cli -> expo설치

expo init 프로젝트명 -> 프로젝트 생성

npx expo start  ||   npm start  -> 프로젝트 실행

CLI(Commend-Line-Interface): 사용자가 컴퓨터에게 명령을 입력하여 상호작용하는 방식


JSX문법
여러개의 태그는 반드시 하나로 묶어야 함
React-Native는 <div>역할을 하는 <View>라는 컴포넌트가 있음
Fragment를 써도 됨
if문 가능, 3항 연산자 가능
&& : 앞의 조건이 참이면 뒤의 조건을 렌더링 함
|| : 앞의 조건이 거짓이면 뒤의 조건을 렌더링 함

null과 undefined
- 조건에 따라 출력하는 값을 변경하다보면 컴포넌트가 null이나 undefined를 반환하는 경우가 있음

JSX의 경우 null은 허용하지만 undefined는 오류가 발생함

스타일링
인라인 스타일링
- JSX에서는 HTML과는 달리 style에 문자열로 입력하는 것이 아닌 객체 형태로 입력해야함
- 속성은 카멜표현식으로 작성해야함


컴포넌트
- 재사용이 가능한 조립블록
- ui의 조각
- 컴포넌트는 단순히 UI의 역할만 하는 것이 아니라 부모로부터 받은 속성(props)나 자신의 상태(state)에 따라
  달라지고 다양한 기능을 수행함
- 리액트 네이티브는 데이터와 UI 요소의 집합체라고 할 수 있는 컴포넌트를 이용하여 화면을 구성함

특징
독립적임
- 컴포넌트는 다른 코드와 독립적으로 동작함
- 한 곳에서 수정해도 다른 부분에 영향을 주지 않음
- 한 번 작성한 컴포넌트를 여러곳에서 사용할 수 있음
- 예를 들어, 앱에서 같은 스타일의 버튼이 필요하다면 버튼 컴포넌트를 만들어 원하는 곳에서 재사용할 수 있음

유지보수가 용이함
- 화면의 각 부분을 작은 컴포넌트로 분리하여 만들기 때문에 필요한 부분만 수정할 수 있음

가독성 증가
- 코드가 잘게 나누어지기 때문에 이해하기 쉽고 코드관리가 수월함


내장 컴포넌트
- 리액트 네이티브에서는 다양한 내장 컴포넌트들이 제공됨

View와 Text
View
- 가장 기본적인 레이아웃 컴포넌트, HTML의 <div>와 유사한 역할을 함
- 화면에 여러 요소를 그룹화하거나 레이아웃을 구성할 때 사용됨

Text
- 텍스트를 표시할 때 사용하는 컴포넌트
- <p>, <span>과 비슷하며 React-Native에서 텍스트를 표시할 때 필수적으로 사용됨

Button
- React-Native에서 사용하는 버튼을 만들어주는 컴포넌트 
- 설정할 수 있는 속성들이 있음
-- title: 버튼에 쓰이는 문구
-- onPress : 클릭 이벤트
-- color속성 : IOS에서는 텍스트의 색 안드로이드에서는 버튼의 배경색을 나타내는 값
-- ScrollView : 스크롤이 가능한 뷰를 만들 때 사용하는 컴포넌트

커스텀 컴포넌트 만들기
- React-Native에서 다양한 컴포넌트를 제공하고 있지만 프로젝트를 진행하다보면 여러 컴포넌트를 조합해서
  새로운 컴포넌트를 제작하여 사용하게 됨
- React-Native에서 제공하는 컴포넌트들을 이용해서 커스텀 컴포넌트를 만들 수 있음

- Pressable과 Text 컴포넌트를 이용해서 MyButton컴포넌트를 만들 수 있음

Pressable컴포넌트
- 터치 이벤트에 대한 더 세부적인 제어를 제공하는 최신 터치 컴포넌트로 다양한 상태와 조건을 다루기 위해 
  만들어짐
- 터치 가능 영역을 정의하는 컴포넌트로 사용자가 터치, 길게 누름, 눌렀다 뗌 등의 여러 이벤트를 
  처리할 수 있음
- 각 이벤트에 따른 다양한 콜백 함수를 제공해 더 세밀하게 터치 상호작용을 제어할 수 있음

주요 이벤트와 콜백함수
onPress : 눌렀다 뗐을 때 호출
onPressIn : 누르는 순간 호출
onPressOut : 눌렀다 떼는 순간 호출
onLongPress : 사용자가 지정된 시간 이상 길게 눌렀을 때 호출

자식 컴포넌트로 데이터를 전달하는 방식
1. 부모 컴포넌트에서 자식 컴포넌트를 사용하면서 속성으로 props를 전달하는 방법
2. 컴포넌트의 태그 사이에 값을 입력해서 전달하는 방법


defaultProps
만약 사용해야 하는 값이 전달되지 않았다면 기본으로 사용되는 값
여러 사람과 개발을 하면 내가 만든 컴포넌트를 다른사람이 사용하는 경우가 많음
이런 상황에서 컴포넌트를 잘못 파악해 반드시 전달되어야 하는 중요한 값이 전달되지 않았을 때
기본값을 지정하면 만약의 사태에 빈 값이 나타나는 상황을 막을 수 있음

propsTypes
프로젝트의 크기가 커지면서 컴포넌트에 props를 전달할 때 잘못된 타입으로 전달하거나, 필수로
전달해야 하는 값을 전달하지 않아서 문제가 생길 수 있음
혹은 협업하는 다른 개발자가 잘못 전달할 수도 있음
이런 상황에서 잘못된 props가 전달되었다는 것을 경고 메시지를 통해 알리는 방법으로
propsTypes를 사용하는 방법이 있음

최신 React-Native환경에서는 작동을 안할 수 있음

state
props는 부모 컴포넌트에서 받은 값을 변경할 수 없는 반면에 state는 컴포넌트 내부에서 생성되고 값을
변경할 수 있으며 이를 이용해 컴포넌트 상태를 관리함
상태(state)란 컴포넌트에서 변화할 수 있는 값을 나타내며 상태가 변하면 컴포넌트는 재렌더링이 일어남

useState
리액트 Hook중 useState는 함수형 컴포넌트에서 상태를 관리할 수 있도록 해줌

useState()를 실행하고나면 변수와 변수의 값을 변경할 수 있는 함수를 배열로 반환함
상태변수는 직접 변경하는 것이 아니라 useState에서 반환한 setter함수를 이용해야함
useState함수를 호출할 때 파라미터에 생성되는 상태의 초기값을 전달할 수 있고,
초기값을 전달하지 않으면 undefined로 설정되어 에러가 발생할 수 있음


이벤트 처리
React-Native에는 사용자의 행동에 따라 상호작용하는 이벤트를 다양하게 제공함
많은 종류의 이벤트가 존재하고 컴포넌트가 하는 역할에 따라 제공되는 이벤트도 약간씩 차이가 있음

Press 이벤트
React-Native에서 onClick이벤트와 가장 비슷한 이벤트는 Press 이벤트임
버튼을 만들 때 Pressable 컴포넌트에서 설정할 수 있는 Press이벤트의 종류는 4가지임
onPress : 눌렀다 뗐을 때 호출
onPressIn : 누르는 순간 호출
onPressOut : 눌렀다 떼는 순간 호출
onLongPress : 사용자가 지정된 시간 이상 길게 눌렀을 때 호출

버튼 클릭시
onPressIn -> onPress -> onPressOut

버튼을 꾹 누르고 있을시
onPressIn -> onLongPress -> onPressOut

onPress와 onLongPress는 사용자가 클릭하는 시간에 따라 둘 중 하나면 호출이 됨
만약 onLongPress가 호출되는 시간을 조절하고 싶다면,
delayLongPress속성을 주면 됨

change 이벤트
변화를 감지하는 change 이벤트는 값을 입력하는 TextInput컴포넌트에서 많이 사용됨

onChangeText  
컴포넌트의 텍스트가 변경되었을 때 변경된 텍스트의 문자열만 인수로 전달하여 호출됨

Pressable 컴포넌트
사용자의 터치에 상호작용하는 컴포넌트
우리는 모바일 환경에서 작은화면에 버튼을 포함하여 다양한 요소들을 보여줌
화면이 작은 만큼 버튼도 작아지는데 손가락이 크거나 두꺼운 사람들은 
버튼을 정확하게 클릭하는 것이 어려울 수 있음
이런 상황을 해결하기 위해 많은 개발자들이 버튼 모양보다 약간 떨어진 부분까지 이벤트가 
발생할 수 있도록 조치하고 있음

Pressable컴포넌트는 HitReact를 이용해 이러한 설정을 할 수 있음


스타일링

1. 인라인 스타일링
HTML의 인라인 스타일링 처럼 컴포넌트에 직접 스타일을 입력하는 방식
다만 HTML에서는 문자열 형태로 스타일을 입력하지만 React-Native에서는 객체형태로 전달해야 
하는 차이점이 있음

클래스 스타일링
- 컴포넌트의 태그에 직접 입력하는 방식이 아니라 스타일시트에 정의된 스타일을 사용하는 방법
- 웹에서 css클래스를 이용하는 방법과 유사함

StyleSheet
- React-Native의 내장 객체로 화면에 표시될 요소들의 디자인을 지정하는 역할을 함
- 모바일 환경에서 동작하기 때문에 웹 처럼 CSS스타일을 작성하는 방식은 비효율적일 수 있음
- StyleSheet를 사용하면 코드의 성능이 개선되고 스타일을 체계적으로 관리할 수 있게 됨

StyleSheet.create메서드를 호출해 스타일을 정의함
이 메서드를 통해 스타일을 객체 형태로 작성할 수 있음

외부 스타일 시트 이용하기
상황에 따라 외부 파일에 스타일을 정의하고 여러개의 파일에서 스타일을 공통으로 사용하는 
경우가 있음

리액트 네이티브 스타일
- React-Native에는 많은 종류의 스타일 속성들이 있음
- 그중에는 특정 플랫폼에서만 적용되는 스타일도 있고, 웹 프로그래밍에서 사용해본 
  익숙한 속성들도 있음

React-Native에서도 요소의 너비와 높이를 정할 때 width와 height를 설정할 수 있음
- Header와 Footer 컴포넌트의 높이를 80으로 하고 Contents컴포넌트가 나머지 영역을 차지하도록
  구성하고 싶으면 어떻게 해야하나?

Platform
앱이 실행되는 운영체제에 따라 다른코드를 실행할 수 있게 도와주는 도구

1. Platform.OS
현재 실행중인 플랫폼을 알려주는 값

2. Platform.select
운영체제별로 서로 다른 값을 쉽게 설정할 수 있게 해줌

styled-components
자바 스크립트 파일안에 스타일을 작성하는 CSS-in-JS라이브러리 이며 스타일이 적용된 컴포넌트
npm install styled-components --legacy-peer-deps

'--force': 모든 충돌을 무시하고 강제로 최신버전 설치
'--legacy-peer-deps ' : npm7에서 peer dependencies라는 새로운 기능이 나옴
		     버전에 충돌이 일어나는 경우 에러로 판단해 설치를 중단
		     peerDependencies가 자동으로 설치되는 기능을 무시


백틱(``)안에서 props에 접근할 수 있다는 장점으 이용해 props의 값에 따라 스타일변경을 할수도 있음

styled-component의 사용법
const 컴포넌트명 = styled.View`
	css
`

props를 전달하면 값에 따라 css를 다르게 적용할 수도 있음

attrs사용
스타일드 컴포넌트를 사용하면 스타일을 작성하는 곳에서 컴포넌트의 속성도 설정할 수 있음
그리고 속성을 설정할 때도 전달된 props를 사용할 수 있으므로 props의 값에 따라 속성을 변경할 수 있음

ContextAPI
데이터를 전역으로 관리하기 위해서 사용하는 기능
어플리케이션 전체에서 스타일드 컴포넌트를 이용할 때 미리 정의한 값을 사용할 수 있도록 props로 전달함

스타일드 컴포넌트에서는 ThemeProvider라고 하는 컴포넌트를 제공함 props로 우리가 설정한 테마를 전달

테마를 넘기고 싶은 컴포넌트에 ThemeProvider로 감쌈
<ThemeProvider theme={우리가 만든 테마}>

</ThemeProvider> 

스타일드 컴포넌트를 사용할 때 ThemeProvider를 활용하여 theme를 지정하면 하나의 파일에서 미리 정의해둔
색을 하위 컴포넌트에서 사용할 수 있음
하나의 파일에서 모든 색을 관리하면 색의 사용이나 변경 등 유지보수에서 많은 이점을 얻을 수 있음

Switch컴포넌트
토글 스위치 UI를 만드는 기본 컴포넌트
설정 화면에서 ON/OFF기능을 구현할 때 사용함
주요 props
value : 스위치의 현재 상태 (켜짐 / 꺼짐) boolean
onChangeValue : 스위치 상태가 바뀔 때 실행되는 함수 function
disabled : 스위치 비활성화 여부 boolean



Todo 프로그럄
등록 : 할 일 항목을 추가하는 기능
수정 : 완료되지 않은 할 일 항목을 수정하는 기능
삭제 : 할 일 항목을 삭제하는 기능
완료 : 할 일 항목의 완료 상태를 관리하는 기능

타이틀 만들기
가장 먼저 화면 상단에 TODO List라는 문구가 렌더링 되도록 타이틀을 만들기
App컴포넌트에 스타일드 컴포넌트를 이용해 Title컴포넌트를 만듬

SafeAreaView
아이폰처럼 노치 디자인이 있는 기기는 Title의 일부가 가려지는 것을 볼 수 있음
React-Native에서는 자동으로 padding값이 적용되어 노치 디자인 문제를 해결할 수 있는 
SafeAreaView 컴포넌트를 제공함

StatusBar
배경색을 어려운 색으로 설정하면서 상태바의 내용도 눈에 잘 들어오지 않는다는 문제가 있음
상태바를 변경해 안드로이드에서 Title컴포넌트가 가려지는 문제를 해결하고 어두운 배경에 잘보이도록
스타일을 수정

주요 props
barStyle : default(시스템 기본 스타일), light-content(흰색 글자), dark-content(검은색 글자)
backgroundColor : 배경색(Android전용)

Input컴포넌트 만들기
- TextInput 컴포넌트를 이용해 Input컴포넌트를 만들기
- Input 컴포넌트는 할 일 항목을 추가할 때 뿐만 아니라 등록된 할 일 항목을 수정할 때도 사용할 예정임

Dimensions
기기의 화면 크기나 요소의 크기를 가져오기 위해 사용하는 모듈
앱을 개발할 때 화면 크기를 기준으로 요소를 배치하거나 스타일을 설정해야 할때 Dimensions를 사용하면 화면
크기에 따라 동적으로 레이아웃을 구성할 수 있음

예를 들어, 큰 테블릿 화면과 작은 스마트폰 화면에 같은 크기의 요소를 배치하면 UI가 
비정상적으로 보일 수 있음 이 때, Demensions 모듈을 사용해 현재 기기의 화면과 너비와 높이를 가져와
화면 크기에 따라 적절한 크기와 위치를 설정할 수 있음

이벤트
ㅣㅂ력되는 값을 이용할 수 있도록 Input컴포넌트에 이벤트처리를 해야함

할일 목록 만들기
Input컴포넌트를 통해 입력받은 내용을 목록으로 출력하는 기능 만들기
할 일 목록을 만들기 위해서는 2개의 컴포넌트가 필요함
IconButton: 완료, 수정, 삭제 버튼으로 사용할 컴포넌트
Task : 목록의 각 항목으로 사용할 컴포넌트

아이콘 버튼 컴포넌트를 만들기전에 프로젝트에서 사용할 아이콘이미지를 다운로드 받아야함


완료기능
완료 여부를 선택하는 버튼의 기능을 구현
항목을 완료상태로 만들어도 다시 미완료 상태로 돌아올 수 있도록 완료버튼을 만들기


입력 취소
항목을 추가하거나 수정하는 도중에는 입력을 취소할 방법이 없음
입력중에 다른영역을 클릭해서 Input 컴포넌트가 포커스를 잃으면 입력중인 내용이 사라지고 취소되도록
Input컴포넌트를 수정



AsyncStorage를 이용해서 로컬에 데이터를 저장하고 불러오는 기능을 구현할 수 있음
AsyncStorage는 비동기로 동작하여 문자열로 된 키-값 형태의 데이터를 기기에 저장하고 불러올 수 있는 기능을 제공

key를 이용하여 데이터에 접근하고 값을 불러오거나 저장할 수 있음

비동기 API를 제공하기 때문에 데이터 저장과 로딩이 메인 스레드를 차단하지 않음

사용자 설정
테마, 언어, 알림설정 같은 개인화 옵션을 저장하고 불러올 때 유용

세션 관리
인증 토큰이나 사용자 상태를 저장해 로그인 상태를 유지할 때 사용할 수 있음

앱 초기화 상태
사용자가 앱을 처음 열 때 실행되는 초기 설정이나 튜토리얼 진행 상태 등을 저장할 수 있음

간단한 데이터 캐싱
네트워크 데이터를 캐싱하거나 오프라인 상태에서 사용할 간단한 데이터를 저장할 수 있음


AsyncStroage
앱 내에 데이터를 로컬에 영구적으로 저장할 수 있도록 해주는 비동기 저장소 시스템

리액트 할 때 로그인하면 토큰을 반환받고 localStorage에 저장한 것과 비슷한 시스템

AsyncStorage는 비동기로 작동하고 JSON기반으로 key-value형태로 데이터를 저장함

언제 사용하나?
사용자가 로그인 한 상태를 유지하고 싶을 때
최근 검색어, 설정값, 토글 상태 등을 기억하고 싶을 때


value에 넣을 때 JSON.stringify로 변환을 해서 저장
setItem(key, value)

const user = {
	id : 1,
	name : 'name'
}
await AsyncStorage.setItem('user', JSON.stringfy(user));

실제 저장되는 내용은
key : user
value : "{\"id\":1,\"name\":\"name\"}"

저장된 데이터를 확인하는 법
getItem(key)

const data = await AsyncStorage.getItem(key)

저장된 전체 key불러오기
const keys = await AsyncStorage.getAllKey()


화살표 함수는 쓰는 이유
1. 즉시 호출 방지
컴포넌트가 렌더링 될 때 setCount(count +1이 즉시 실행되어 onPress이벤트가 발생할 때가 아닌 
렌더링 시점에 setCount가 호출됨

2. this 바인딩 문제 해결
리액트 클래스 컴포넌트에서는 일반적으로 이벤트 핸들러에 this가 현재 컴포넌트를 참조하도록 사용했어야 함


hooks
함수형 컴포넌트에서 상태를 관리하거나 라이프사이클 같은 기능을 사용할 수 있도록 해주는 기능

기존에는 이런 기능을 사용하려면 클래스형 컴포넌트로 사용해야 했지만 hook 덕분에 함수형 컴포넌트에서도
복잡한 상태 관리와 로직 분리가 가능해졌음

hook은 함수형 컴포넌트 안에서만 호출할 수 있으며 use로 시작하는 이름을 가짐

useState의 상태 저장 및 변경
상태는 컴포넌트가 재렌더링될 때 유지가 됨
상태 변경함수를 사용하면 컴포넌트가 자동으로 재렌더링됨
useState가 부모 컴포넌트에 있고 함수를 자식컴포넌트에 전달해서 state를 수정해도 부모 컴포넌트에 있는
상태의 값이 바뀌게됨

상태 변경 함수는 비동기적으로 동작함
변경 직후의 state값을 바로 읽으면, 여전히 이전 값일수도 있음
상태 변경 함수는 즉시 상태를 변경하는 것이 아니라, React가 다음 렌더링 타이밍에 상태를 변경하고 
컴포넌트를 다시 렌더링함

React는 성능 최적화를 위해, 여러개의 setCount(count+1)가 호출이 될 때 하나의 렌더링 사이클로 
묶어서 처리함 
일괄 업데이트(batch update)
setCount(count+1)
setCount(count+1)
setCount(count+1)
이렇게 3번을 호출해도 실제로는 한 번만 렌더링됨

이전 상태 값이 꼭 필요한 경우 반드시 함수형 업데이트를 사용해야 함
setCount(prev => prev+1)
setCount(prev => prev+1)
setCount(prev => prev+1)


useEffect
컴포넌트가 렌더링되었을 때 특정 동작을 수행하는 훅
서버에서 데이터를 불러올 때 많이 사용
두번째 인자인 의존성 배열에 값을 넣고 값이 바뀔때마다 다시 실행할 수 있음


useRef
DOM참조나 변수 저장용(렌더링 없이 값만 기억하고 싶을 때)
특정 DOM요소나 값의 변화를 추적하거나 유지할 때 사용되는 객체를 반환해주는 역할
DOM요소에 접근하기 위해 사용하거나, 재렌더링 없이 상태를 유지할 때 사용하는 경우가 많음

주요특징
- 초기값 유지
  useRef의 초기값은 컴포넌트가 마운트될 때 한 번만 설정되며 이후에는 유지됨
- 재렌더링 없이 값 유지
  useRef의 값이 바뀌어도 컴포넌트는 재렌더링되지 않으므로 값의 변경이 UI에 즉각적인 영향을 
  주지 않아야할 때 유용함
- DOM에 접근
  컴포넌트의 특정 DOM요소에 접근할 때 사용할 수 있음
  주로 INPUT, BUTTON 등 특정 DOM요소에 직접 접근해 포커스를 설정하거나, 요소의 값을 직접 조작할 때 
  사용됨


const ref = useRef(초기값)


useMemo
메모이제이션을 통해 특정 연산의 결과를 저장해두고 불필요한 반복 계산을 피하도록 도와줌
이 훅은 복잡한 계산이 매번 다시 이루어지지 않도록 최적화하는 역할을 하며 의존성 배열에 따라 값이
바뀔때만 연산이 다시 수행되도록 설정할 수 있음
불필요한 계산을 줄이기 위해 사용하는 서능 최적화용 훅

메모이제이션이란 같은 계산을 반복해야할 때 그 결과를 저장해두고 다시 필요할 때 저장된 값을 꺼내 
사용하는 기법

반복적으로 동일한 연산을 수행하지 않아도 되어, 성능이 크게 향상됨
useMemo가 이 메모이제이션을 사용할 수 있도록 지원하는 훅임

동작 방식
useMemo는 특정 계산의 결과를 기억하고 있다가 다음에 해당 계산이 필요할 때 의존하는 값이 바뀌지 않으면
이전 결과를 그대로 반환함

useMemo(() => {}, []);

첫번째 인자(값을 계산하는 로직)
결과적으로 return값이 memoizedValue에 저장됨
계산 비용이 크거나 복잡한 로직을 여기에 작성함

두번째 인자는 의존성 배열
이 배열 안의 값 중 하나라도 변경되면, 첫 번째 함수가 실행됨
이 배열이 변하지 않으면 이전에 계산된 값을 재사용함

의존성 배열을 비워두면 마운트시 한번 계산하고 끝이나기 때문에 오류 발생 가능성이 있음
반드시 의존하는 값은 두번째 인자에 포함시켜야함

메모이제이션(memoization)
함수의 결과값을 어딘가에 저장해뒀다가, 같은 입력이 들어오면 다시 계산하지 않고 저장된 값을 
재사용하는 기법

리액트 내부의 훅 저장소에 그 컴포넌트 객체에 연결된 형태로 값이 저장됨


useReducer훅
복잡한 상태의 로직을 보다 체계적으로 관리하기 위해 사용하는 상태 관리 훅
리듀서라는 함수를 통해 상태를 업데이트하는 방식이며, Redux를 간소화시킨 버전이라고 생각하면 됨

const[state, dispatch] = useReducer(reducer, initialState)
state : 현재 상태의 값
dispatch : 상태를 바꾸기 위해 액션을 보내는 함수
reducer : 상태 업데이트 로직을 담은 함수
initialState : 초기 상태 값

언제 useReducer훅을 사용하면 좋은가?
상태가 복잡하고 조건이 많을 때
여러 상태가 하나의 로직으로 연결됐을 때
컴포넌트에서 상태 로직을 분리하고 싶을 때


커스텀 hook 만들기
여러 컴포넌트에서 사용하는 로직을 재사용 가능한 함수로 만들 수 있음
복잡하거나 반복되는 훅 사용코드를 조합해 나만의 훅으로 만드는 것
이름은 반드시 use~로 시작해야함
우리가 만들 hook함수는 API에 GET요청을 보내고 응답을 받는 함수
리액트 네이티브에서는 네트워크 통신을 위해 fetch, axios를 제공하고 추가적으로 WebSocket도 지원함

이번에는 fetch를 이용해 useFetch라는 이름의 hook을 만듬


map 메서드
배열에 들어있는 요소들을 하나씩 순회하면서 변화를 주고 싶을 때

reduce 메서드
배열의 모든 요소를 하나의 값으로 누적해주는 함수
array.reduce((누적값, 현재값) => {return 새로운 누적 값}, 초기값)

누적값 : 이전 반복에서 반환받은 값
현재값 : 현재 순회중인 배열의 요소
초기값 : 누적값의 초기값(생략하면 배열의 첫번재 요소가 초기값)

forEach() : 하나씩 출력(콘솔에 출력할 때 많이 사용)
map() : 각 요소를 변환해서 새로운 배열을 반환
filter() : 조건을 만족하는 요소만 남겨서 새 배열로 반환
reduce() : 누적 계산을 수행
some() : 하나라도 조건을 만족하면 true
every() : 모두가 조건을 만족해야 true
find() : 조건에 맞는 첫번째 요소를 반환

래액트 or 리액트 네이티브는 조건부 렌더링이 매우 자주 필요함
그렇기 때문에 삼항연사자, 논리 연산자를 많이 사용함
JSX는 HTML과 JS가 섞인 형태이지만 JSX안에서는 if문을 직접 사용할 수 없음
따라서 삼항연산자 나 논리연산자를 이용해야만 함

삼항연산자
명확한 두가지 경우의 처리
{isLoggedIn ? <Text>환영합니다</Text> : <Text>로그인 해주세요</Text>}

논리 연산자
조건을 만족할 때만 렌더링 할 때
{hasError &&  <Text style={{color:'red'}}>에러발생</Text>}



Context API
상태를 전역적으로 관리할 수 있음

최상위 컴포넌트에서 하위 컴포넌트를 많이 거쳐야 할 때 중간 단계 컴포넌트들을 거쳐야하는 문제가 있었음
특정 데이터를 사용하지 않는 중간 컴포넌트 들고 props를 받은 다음에 자식 컴포넌트로 전달해야 하기
때문에 코드가 복잡해지고 가독성이 떨어지며 유지보수가 어려워짐

컴포넌트가 특정 데이터와 강하게 결합이되면 해당 컴포넌트를 다른 곳에서 사용하기가 어려워짐
개별적으로 사용하려고 만든 컴포넌트인데 독립적으로 사용하는 것이 어려워질 수 있음

상태의 관리와 동기화에 어려움
상태가 상위 컴포넌트에 위치하고, 컴포넌트의 계층이 깊을 수록 상태를 업데이트하는 과정이 복잡해짐

상위에서 하위로 데이터를 전달하는 과정에서 버그가 발생할 가능성이 있음

불필요한 재렌더링
상위 컴포넌트의 상태가 변경되면 해당 상태를 전달받는 모든 하위 컴포넌트가 재렌더링됨
계층이 깊어지면  상태를 직접적으로 사용하지 않는 중간 컴포넌트까지 재렌더링될 수 있음
이로 인해 성능이 저하되고 어플리케이션이 느려질 수 있음

Provider
Context에 있는 Provider 컴포넌트는 하위 컴포넌트에 Context변화를 알리는 역할을 함
Provider 컴포넌트는 value를 받아서 모든 하위 컴포넌트에 전달하고, 하위 컴포넌트는 value가 변경될 때마다
다시 렌더링 됨

App컴포넌트를 Provider컴포넌트로 감쌌기 때문에 User컴포넌트에서 사용된 Consumer 컴포넌트는 더이상 
Context의 기본값을 사용하지 않고 Provider컴포넌트가 전달하는 데이터를 사용하도록 변경되었음

Provider 컴포넌트에서는 어떤 값도 전달되지 않고 Consumer컴포넌트의 자식으로 지정된 함수의 파라미터로
undefined가 전달되면서 오류 메시지가 나타남
이 문제는 Provider컴포넌트의 value에 값을 전달하여 해결할 수 있음



네비게이션
- 모바일 어플리케이션은 하나의 화면으로 구성되는 경우가 거의 없으며, 일반적으로 다양한 화면이 상황에
  맞게 전환되면서 나타남
- 그렇게 때문에 네비게이션은 모바일 어플리케이션에서 가장 중요한 기능 중 하나라고 할 수 있음
- 리액트 네이티브에서는 네비게이션 기능을 지원하지 않으므로 외부 라이브러리를 이용해야함

리액트 네비게이션
- 리액트 네비게이션 라이브러리는 리액트 네이티브 어플리케이션의 네비게이션을 쉽고 간단하게 관리 할 수
  있도록 도와줌
- 지원하는 네비게이션의 종류는 Stack, Tab, Drawer 세종류가 있음

네비게이션의 구조
리액트 네비게이션에는 
- Navigation Container 컴포넌트
- Navigation 컴포넌트
- Screen 컴포넌트가 있음

Screen 컴포넌트
네비게이터(Navigator)안에서 각각의 화면을 정의하는데 사용되는 기본 단위
- Screen은 네비게이션 구조에서 이동할 수 있는 독립적인 화면을 의미하며, 각 Screen은 하나의 
  컴포넌트를 가리킴
속성
name : Screen 컴포넌트의 식별자가 됨, 이름값을 통해 다른 화면에서 해당 화면으로 네비게이션 할 수 있음
component : Screen에 할당된 컴포넌트로 이 속성에 지정된 컴포넌트가 화면에 렌더링 됨

특징
화면으로 사용되는 컴포넌트에는 항상 navigation과 route가 props로 전달된다는 특징이 있음

리액트 네이티브에서 특정 컴포넌트를 네비게이터에 Screen으로 등록하면 그 컴포넌트는 네비게이션에 의해
관리되는 "화면"역할을 함

스택 네비게이션
- 가장 기본적인 네비게이션인 스택
- 스택 네비게이션은 일반적으로 가장 많이 사용되는 네비게이션임, 화면 위에 화면을 쌓으면서 이동하는 것이
  특징임
- 예를 들어, 채팅 어플리케이션에서 채팅방에 입장하는 상황이나 여러 목록 중 특정 항목의 상세화면으로 
  이동 할 때 사용됨
- 스택 네비게이션은 화면 위에 새로운 화면을 쌓으면서(push) 이동하기 때문에 이전 화면을 계속 유지함
- 이런 구조 때문에 가장 위에 있는 화면을 들어내면(pop) 이전 화면으로 돌아갈 수 있다는 특징이 있음


화면의 이동
Screen 컴포넌트의 component로 지정된 컴포넌트는 화면을 이용이 되고 navigation이 props로 전달이 됨

navigation에는 다양한 기능이 있는데 그중 navigate메서드는 원하는 화면으로 이동하는데 사용되는 함수



네비게이션의 종류
1. Stack
2. Tab
3. Drawer

@react-navigation/native
스택, 탭, 드로어 같은 화면 전환 네비게이션 기능을 제공하는데 여기서 네비게이션 컨텍스트와 네비게이션 
상태를 관리하는 기능을 담당함
이 패키지 자체는 네비게이션 로직만 담당하고, 실제로 화면 전환 애니메이션이나 제스처 처리는 다른 
라이브러들이 필요함

react-native-gesture-handler
제스처(터치, 스와이프 등)를 더 부드럽고, 정확하게 해주는 라이브러리

react-native-reanimated
애니메이션을 자바스크립트 스레드가 아니라 네이티브 스레드에서 직접 실행해서 렉 없이 부드러운 
애니메이션을 구현할 수 있음

react-native-screens
화면간 전환을 더 최적화하는 라이브러리
스택 네비게이션에서 이전 화면을 메모리에 남겨둘 때 불필요한 리렌더링을 막아주고 전환 성능이 빨라짐

react-native-safe-area-context
- 노치, 홈인디케이터, 상단 상태바 같은 디바이스의 안전영역을 인식하고 컴포넌트가 그 안에 렌더링되게
  해주는 라이브러리
- 디바이스 별로 달라지는 안전영역 정보를 제공하고, 그에 맞게 padding / margin조정이 가능함

@react-native-community/masked-view
특정 뷰(View)를 마스크 처리해서 뷰의 특정 영역만 보여줄 수 있게 하는 기능
화면 전환할 때 부드럽게 보여주는 기능

@react-navigation/stack
스택 네비게이션을 구현하는 라이브러리
사용자가 화면간에 이동할 수 있게 만들어줌
스택 구조로 페이지를 쌓고 쌓인 페이지를 제거하면서 이동하는 구조
함수
1. createStackNavigator()
스택 네비게이터를 생성하는 함수
반환되는 객체 안에 Navigator, Screen 컴포넌트를 포함하고 있음

2. Stack.Navigator
스택 네비게이션을 설정하는 컴포넌트, 여러개의 Screen 컴포넌트를 포함할 수 있음
ㄴ> screenOptions : Navigator가 감싸고 있는 모든 스크린에 대해 설정을 적용

3. Stack.Screen
스택 안에 들어가는 하나의 화면
ㄴ> 이름과 컴포넌트를 지정해야함
ㄴ> options : 해당 스크린에만 설정을 적용


useNavigation()
현재 스크린의 navigation객체를 얻어와서 화면 이동같은 네비게이션 기능을 사용할 수 있게 해줌
이 navigation 객체는 원래 스크린 컴포넌트에 props로 자동 전달이 되지만, 컴포넌트가 스크린이 아니거나
더 깊은 하위 컴포넌트에서는 props로 바로 받을 수 없음, 이때 useNavigation()을 써서 사용할 수 있음


@react-navigation/native
@react-navigaion/stack
react-native-gesture-handler

1. 화면으로 사용할 컴포넌트들을 만듬
Home.js
List.js
Item.js

2. 스택 네비게이션을 구성
Stack.js

2-1. createStackNavigator()를 통해 스택 객체를 생성
const Stack = createStackNavigator();

Stack객체는 Navigator와 Screen이라는 컴포넌트를 제공함

<Stack.Navigator>
	<Stack.Screen name = "Home" component = {Home}/>
	<Stack.Screen name = "List" component = {List}/>
	<Stack.Screen name = "Item" component = {Item}/>
</Stack.Navigator>

스타일이 반영되는 순위
1. navigation.setOptions
2. Screen의 options
3. Navigator의 screenOptions

useLayoutEffect 훅
useEffect와 사용법이 동일하며 거의 같은 방식으로 동작함
차이점은 컴포넌트가 업데이트된 직후 화면이 렌더링되기 전에 실행이 된다는 것
이 특징 때문에 화면을 렌더링하기 전에 변경할 부분이 있거나 수치 등을 측정해야 하는 상황에서 많이 사용함


navigation 객체의 내장 메서드
navigate('목적지,'데이터') : 특정 스크린으로 이동
goBack() : 스택에서 현재 스크린 pop
popToTop() : 스택의 맨 아래 화면으로 돌아가기

헤더 감추기
화면의 종류나 프로젝트에 따라 헤더를 감춰야하는 상황이 있음

headerMode
Stack.navigator에서 모든 화면에서 헤더가 표시되는 방식을 설정함
headerMode에는 다음과 같은 세가지 설정값이 있음
screen : 각 화면마다 개별적으로 헤더가 나타남 화면이 전환될 때마다 새로운 헤더가 렌더링 됨
           화면 전환 시 이전 화면의 헤더가 사라지고 새화면의 헤더가 나타나는 방식임
float : 헤더가 모든 화면을 관통하여 부드럽게 애니메이션되며 화면간의 전환 시 부드러운 전환 효과가 있음
        두 화면 간 전환 시 헤더는 이동하지 않고 그대로 유지되는 느낌을 줌
none : 헤더를 표시하지 않음 모든 화면에서 헤더가 사라지며, 이를 통해 전체화면을 사용하거나 커스텀 헤더를
         구현할 수 있음

React Navigation v6가 되면서 headerMode는 없어졌고
Navigator에 쓰고 싶으면
setOptions={{
	headerShown : true,
}} 이런 식으러 주면 됨

headerShown
각 Screen에 대해 헤더를 개별적으로 표시할지 여부를 설정하는 옵션임
headerShown 옵션은 true 또는 false값을 가짐

탭 네비게이션
@react-navigation/bottom-tabs
리액트 네이티브에서 하단 탭 네비게이션을 만들기 위해 사용하는 라이브러리
보통 화면 위나 아래에 위치하며, 탭 버튼을 누르면 버튼과 연결된 화면으로 이동하는 방식으로 동작함

인스타그램 하단 탭
유튜브 하단 탭
카카오톡 하단 탭 등...

createBottomTabNavigator() : 하단 탭 네비게이터를 생성하는 함수

Tab.Navigator

Tab.Screen

화면 구성
3개의 버튼과 해당 버튼에 연결된 화면으로 구성된 탭 네비게이션을 만들기

탭 네비게이션의 기본 설정에는 탭 버튼 아이콘이 지정되어 있지 않음
탭 버튼에 아이콘을 렌더링하는 방법은 tabBarIcon을 이용하는 것임

Drawer Navigation
화면을 옆에서 슬라이드하여 나타나는 메뉴를 통해 다른 화면으로 이동할 수 있게 해줌
주로 좌측이나 우측에서 나타나는 메뉴 형식으로 구현됨, 사용자 경험을 높이는데 도움이 됨
- 앱의 주요 메뉴나 설정 화면 등 쉽게 접근할 수 있는 화면을 배치할 때 유용

DrawerContentScrollView
드로어에 들어가는 내용을 스크롤 할 수 있게 해주는 컴포넌트
안에 들어가는 모든 내용은 이 ScrollView 안에 있어야 드로어가 길어졌을 때 스크롤이 가능함

DrawerItemList
Drawer.Navigator에 등록된 스크린들을 자동으로 메뉴 항목으로 만들어주는 컴포넌트

<DrawerItemList {...props} />


채팅 프로그램

구현할 기능
로그인 / 회원가입 : 이메일과 비밀번호를 이용한 로그인과 회원가입
프로필 : 나의 정보 확인 및 변경
채널 생성 : 채널 생성 기능
채널 목록 : 생성된 채널들의 목록 조회
채널 : 실시간으로 메시지를 송수신하는 공간

네비게이션
로그인 등 인증하는 화면
채팅방 목록 등을 확인할 수 있는 화면
메시지를 주고 받는 화면
화면은 유기적으로 연결되어 있으며 화면 간 이동은 잦을 것임

네비게이션 라이브러리 설치

프로젝트를 진행하면서 필요한 라이브러리를 사용해볼 예정

expo-image-picker
기기의 사진이나 영상을 가져올 수 있도록 시스템 UI에 접근할 수 있는 기능을 제공함

moment
시간을 다양한 형태로 변경하는 등 시간과 관련된 많은 기능을 제공하는 라이브러리로 날짜와 관련된
라이브러리 중 가장 널리 알려져있고, 많이 사용되고 있음

타임스탬프를 사용자가 보기 편한 형태로 변경하기 위해 사용할 예정임

react-native-gifted-chat
메시지를 주고받는 채팅화면을 쉽게 구현할 수 있도록 돕는 라이브러리

파이어베이스
구글에서 제공하는 클라우드 기반 개발 플랫폼으로 서버리스 어플리케이션을 쉽게 개발하고 배포할 수 잇도록
다양한 백엔드 서비스를 제공함
주로 모바일 앱과 웹 어플리케이션 개발에 사용되며, 실시간 데이터베이스, 인증, 클라우드 저장소, 푸시 알림
등의 기능을 손쉽게 구현할 수 있음

npm install expo-splash-screen
앱이 실행될 때 사용자에게 보여지는 초기화면(스플래시 화면)을 관리하는 패키지

스플래시 화면 : 앱을 켜면 뜨는 로딩화면

써야하는 이유
앱이 준비되기 전에 빈 화면이나 버벅이는 화면이 보이면 유저는 좋게 생각을 안함
- 앱이 필요한 리소스(글꼴, 데이터, 이미지 등)를 다 로드할 때까지 기다렸다가 사용자에게 보여줄 수 있음


인증 화면
- firebase의 인증 기능을 이용해서 로그인화면과 회원가입 화면을 만들기
- 인증을 위해 이메일과 비밀번호가 필요하므로 로그인 및 회원가입 화면에서는 이메일과 비밀번호를 필수로
  입력받고 회원가입 시 사용자가 서비스에서 사용할 이름과 프로필 사진을 받도록 화면을 구성

주요 기능과 서비스
1. Firebase Authentication
- 다양한 인증 방식을 지원하여 사용자의 로그인과 회원가입을 간편하게 구현할 수 있음
- 이메일 / 비밀번호, 전화번호, 소셜로그인, 익명 인증 등을 제공함

2. Firebase Realtime Database
- 클라우드 기반의 NoSQL 데이터베이스로 데이터가 실시간으로 동기화 됨
- 사용자가 데이터베이스의 업데이트를 즉시 받을 수 있어, 실시간 채팅, 라이브 업데이트 기능 등을 구현할 때
  유용함

3. Cloud Firestore
- 확장성과 유연성을 갖춘 NoSQL문서형 데이터베이스로 Realtime Database와 유사하지만 더 강력하고
  복잡한 쿼리를 지원함

4. Firebase Storage
- 이미지, 동영상, 파일 등을 저장하고 관리할 수 있는 클라우드 스토리지 서비스
- 대용량 파일을 안전하게 저장하고, 업로드 및 다운로드 기능을 손쉽게 구현할 수 있음

5. Firebase Cloud Messaging(FCM)
- 푸시 알림을 전송할 수 있는 무료 메시징 서비스
- 기기 간의 푸시 알림이나 주제별 메시지를 손쉽게 전송할 수 있어, 사용자에게 실시간 알림을 보낼 때 유용함

6. Firebase Hosting
- 정적 웹사이트나 단일 페이지 어플리케이션(SPA)를 위한 빠르고 안전한 호스팅 서비스
- Firebase CLI를 통해 빠르게 배포할 수 있으며, SSL 인증서가 자동으로 적용되어 안전한 HTTPS 통신을 제공함


앱 아이콘과 로딩화면
- 프로젝트의 기능과 화면 개발에 앞서 앱의 아이콘과 로딩화면을 변경

Firebase -> storage -> 규칙
-> match/logo.png{
	allow read;
}

useRef는 key처럼 리액트에서 특별히 관리되기 때문에 자식컴포넌트에 props로 전달되지 않음

이때 forwardRef함수를 이용하면 ref를 전달받을 수 있음 

키보드 감추기
키보드가 Input태그를 가리는 문제와 다른곳을 클랙했을 때 키보드가 사라지게 만들기

버튼 컴포넌트
내부가 채워지지 않은 버튼의 타이틀 색을 다르게 사용하기 위한 값을 정의

에러메시지
이름이 비어 있을 때
Please Enter your name

이메일 형식이 맞이 않을 때
Please verify your email

비밀번호의 길이가 6보다 작을 때
The Password must contain 6 characters at least

비밀번호와 비밀번호 확인이 일치하지 않을 때
Password need to match

모든 조건이 맞을 때
''


입력해야 하는 값이 많은 만큼 유효성 검사와 오류 메시지의 종류가 많아지므로 useEffect를 이용해 관련된
값이 변할 때 마다 적절한 오류 메시지가 렌더링 됨


컴포넌트를 정의하면서 공통적인 부분만 미리 만들어 놓음
각각의 사용처마다 내용이 다른 부분만 props로 받아서 처리
Image -> 이미지의 경로를 미리 지정할 수 없음
Button -> 텍스트, 스타일을 미리 지정할 수 없음
Input -> value를 미리 받을 수 없음

KeyboardAwareScrollView : 키보드가 올라왔을 때 입력창을 가리지 않게 해주는 역할, 내용을 감싸서 적용
contentContainerStyle : ScrollView 안쪽 컨텐츠의 스타일을 설정함
extraScrollHeight : 키보드가 올라갈 때 추가로 스크롤할 높이
enableOnAndroid : 안드로이드에서 키보드 인식 기능을 활성화할지 여부 기본값은 false
enableAutomaticScroll : 포커스된 TextInput이 키보드에 가려질 경우 자동으로 스크롤할 지 여부 기본값은 true

position : absolute
ㄴ> 부모 요소를 기준으로 절대 위치에 배치함
static : 문서의 흐름에 따라 배치
relative : 자기 자신을 원래 위치를 기준으로 문서 흐름이 유지
fixed 브라우저를 기준으로 위치를 고정
sticky static -> fixed처럼 동작하는 하이브리드, 설정한 위치에 도달하면 고정됨

positon이 결정되면 top, right, botton, left 같은 위치 관련 속성을 결정해야함

버튼을 클릭하면 기기의 사진첩에 접근해 사진의  정보를 가져오는 기능을 추가

requestMediaLibraryPermissionsAsync()
{
	status : 'granted', //권한 허용('granted') 또는 거부 ('denied')
	granted : true, //Boolean값, 권한이 허용되었는지 여부
	canAskAgain : true , //사용자가 다시 권한을 요청 받을 수 있는지 여부
	expires : never, //권한 만료 시간('never', 또는 타임스탬프)
}

launchImageLibraryAsync(options)
인자로 전달할 수 있는 옵션
mediaTypes : 선택 가능한 파일 타입 [images, videos, all]
allowEditing : 이미지 선택 후 편집화면을 띄울지 boolean
aspect : 편집시 고정 비율 [1,1]//정사각형 비율
quality : 저장될 이미지 / 비디오의 품질 1은 최고화질

반환값
{
	canceled : boolean,
	assets : [
		{
			uri : string,
			width : number,
			height : number,
			fileSize : number,
			type : string,
			fileName : string,
			duration? : number, //비디오 선택시
	]
}

프로필 이미지 설정
1. 패키지 설치
expo-image-picker

2. ImagePicker.requestMediaLibraryPermissionsAsync() 함수 실행
'granted'를 반환받아야 사진첩에 접근이 가능함

3. launchImageLibraryAsync()
옵션을 주고 실행해서 선택한 이미지의 정보를 돌려받던지, canceled를 돌려받음

4. 사진을 선택했다면 uri를 파싱해 Signup의 photoURL에 전달함

로그인 기능
- 아직 생성된 사용자가 없으므로 파이어베이스 콘솔에서 사용자를 추가하고 로그인 기능을 만들기

getAuth() : 인증 서비스 객체를 만듬
signInWithEmailAndPassword() : 이메일과 비밀번호로 로그인 시도를 하는 함수
Promise를 반환하고, 성공하면 userCredential 객체를, 실패하면 error를 반환함
const credential = {
    user : {
	uid : "사용자의 고유한 ID",
	email : "로그인한 이메일",
	displayName : "설정된 닉네임(없을 수도 있음)",
	photoURL : "프로필 사진 URL(없을 수도 있음)",
	emailVerified : false, -> 이메일 인증 여부
    }
}

createUserWithEmailAndPassword()의 반환값
{
    user : {
	uid : "uid값",
	"email" : "이메일 값",
	"emailverified" : false,
	"displayName" : null,
	photoURL : null,
    }
}

firebase의 Storage에서 쓰기 권한은 로그인한 본인만 가능하도록 하고, 읽기 권한은 누구나 가능하도록
보안 규칙을 수정

Spinner 컴포넌트
로그인 또는 회원가입이 진행되는 동안 데이터를 수정하거나 버튼을 추가로 클릭하는 일이 발생하지 않도록 
Spinner 컴포넌트를 만들어 사용자의 잘못된 입력이나 클릭을 방지하는 기능을 만들기
    