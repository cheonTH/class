<<Servlet/JSP>>
우리가 만든 자바클래스를 서버쪽에서 실행
HTTP요청을 받아 동적으로 응답을 생성할 수도 있음
Servlet -> Java코드 기반 + html 얹어서 사용
JSP-> HTML기반 + Java코드를 삽입해서 동적으로 페이지를 쉽게 작성할 수 있도록 한 기술

서버 - 클라이언트 구조로 전환되어, Applet의 클라이언트 부담을 줄이고 서버에서 로직을 처리하게 됨

<<엔터프라이즈 자바(EJB)>>
- 분산, 트랜잭션, 보안 등 서버사이드 서비스를 제공하는 프레임워크
- 배우기가 어려움, 설정이 복잡하고 프로그램이 너무 무거움

<Spring 프레임워크>
EJB보다 가벼움, 아키텍처가 보다 유연해짐
xml, Java Config어노테이션 설정으로 확장성이 뛰어남

<Spring boot>
Spring에서 직접 해줘야 했던 설정들의 일부도 다 자동화가 됨
웹 서버를 내장하고 있음

백엔드는 화면이 없음 -> 콘솔을 통해서 확인, 데이터를 프론트엔드로 넘겨서 확인

<포스트맨(Postman)>
우리가 만든 기능을 테스트해볼 수 있는 프로그램



CSRF : 웹 어플리케이션에서 사용자가 의도치 않은 상태 변경 요청이 
공격자에 의해 자동으로 전송되도록 하는 공격 기법

start.spring.io
Group 이름은 같아도 되지만 Artifact는 달라야함
프로젝트 이름은 주로 Artifact와 비슷하게함



스프팅 부트 프로젝트의 구성
src/main/java : 서버단 java파일
test/main/java : 테스트하기위한 java파일
src/main/resources : 설정 파일 및 화면에 필요한 파일들
ㄴ> templates: html파일
ㄴ> static폴더: js, css파일
ㄴ> application.properties: 설정 코드가 들어감
build.gradle : 라이브러리 의존성 관리




@SpringBootApplication
@Configuration, @EnableAutoConfiguration, @ComponentScan 세 가지를 하나로 합친 것

@Configuration : 해당 클래스가 설정 파일임을 알려주는 용도
@EnableAutoConfiguration : 스프링의 다양한 설정이 자동으로 구성되고 완료됨
@ComponentScan : 자동으로 컴포넌트 클래스를 검색해서 컴포넌트와 빈(bean)클래스(객체)를 등록



<<스프링부트가 객체를 메모리에 올리는방법>>
Main클래스에 @SpringBootApplication어노테이션에 들어있는 @ComponentScan 어노테이션이
Main클래스가 들어있는 패키지를 모두 탐색하면서 @Component어노테이션이 붙어있는 클래스를
모두 메모리에 올림

Map형식으로 저장을 하는데 key를 클래스의 이름에서 첫글자를 소문자로 바꾸고 저장, value에 객체를 저장함
map.put("computer",new Computer());
ㄴ> 스프링을 통해서 메모리에 올라간 객체를 bean이라고 부름

스프링은 기본적으로 싱글톤 패턴을 지원함
스프링 객체 컨테이너에 한개의 객체만 생성됨
어플리케이션 전반에서 같은 bean을 공유하기 때문에 메모리를 절약하고 bean간의 상태 공유가 가능함



<<스프링의 핵심 개념>>
1. Ioc(Inversion of Control, 제어역전)
객체의 생성과 관리를 개발자가 아닌 프레임워크나 컨테이너가 대신 관리하도록 하는 개념

전통적인 객체 지향 프로그래밍에서 객체 간의 의존성을 개발자가 직접 처리하는 반면
IoC는 이 흐름을 역전시켜 스프링 프레임워크와 같은 컨테이너가 객체 간의 의존성을 주입하고 관리함

IoC는 어플리케이션의 유연성과 유지보수성을 높이는데 기여하며 
스프링 프레임워크에서 가장 핵심적인 개념 중 하나

함수를 호출하는 애 -> 스프링
public User getUser(){ 
	return new User();
}
getUser() 호출했을 때 user객체를 얻을 수 있음

IoC의 주요 개념
1. 의존성 주입(Dependency Injection, DI)
- 객체를 직접 대입하는 것이 아니라 외부에서 필요한 의존성을 주입하는 방식임

2. 제어의 역전
- 전통적으로는 개발자가 직접 객체를 생성하고 관리해야하지만 
IoC에서는 객체의 생성과 생명주기를 스프링이 관리함

즉 개발자가 아니라 프레임 워크가 객체의 생명 주기를 관리하는 방식


<디자인 패턴>
소프트웨어 설계 과정에서 반복적으로 발생하는 문제를 해결하기 위한 재사용 가능한 설계 기법
특정 언어나 플랫폼에 종속되는 것이 아니라 상황과 해법의 구조를 문서화한 유연한 설계도라고 생각하면 됨


<싱글톤 패턴>
스프링이 직접 관리하도록 시킨 클래스는 메모리에 무조건 한번만 올라감
사용할 때는 메모리에 올라가 있는 객체를 받아서 사용함

<팩토리 패턴>
객체 생성 로직을 별도의 클래스로 분리하여 클라이언트 코드가 
구체적인 클래스에 의존하지 않도록 만드는 패턴


<<롬복(lombok)>>
어노테이션 기반의 코드 생성 라이브러리
반복 생성되는 코드들을 줄이기 위해 어노테이션 형식으로 선언할 수 있게 해줌
자바 클래스에서 반복 생성되는 코드 getter, setter, 생성자, toString를 자동으로 생성해줌
- 컴파일 시점에 어노테이션이 코드를 주입하므로, 실제 소스 파일에는 메서드 구현이 보이지 않음

주요 어노테이션의 및 역할
@Getter / @Setter : 필드별 getter / setter 메서드 생성
@ToString : toString()메서드 자동 생성
@EqualsAndHashCode : equals() & hashCode()메서드 생성
@NoArgsConstructor : 파라미터 없는 생성자 생성
@AllArgsConstructor : 모든 필드를 파라미터로 받는 생성자 생성
@RequiredArgsConstructor : final 또는 @NonNull필드만 파라미터로 받는 생성자 생성
@Builder: 빌더 패턴을 지원하는 빌드 클래스를 생성 

의존성 주입(Dependency Injection)
객체가 필요한 의존 관계를 외부에서 주입해주는 설계 원칙
'제어역전'(Inversion of Control)의 한 구현 방식으로 객체 내부가 아니라 
외부 컨테이너가 객체의 생명주기와 관계를 관리함'
제어역전을 구현한 대표적인 기법

필드 주입(Field Injection)
클래스의 필드에 @Autowired를 붙여 스프링이 직접 주입해주는 방식
setter나 생성자없이도 간단히 주입할 수 있다는 특징이 있음

장점 : 필드 선언부에 어노테이션만 붙이면 되므로 다른 코드가 거의 필요 없음

단점 : 불투명성 - 코드만 보고는 어떤 의존성이 언제 주입되는지 파악하는지 어려움
        불변성 미보장 - 초기화 전 필드가 null일 수 있음

간단히 프로토타입을 만들어볼 때 임시로 활용해볼 수 있음


생성자 주입(Consturctor Injection)
객체 생성 시점에 필요한 모든 의존성을 생성자의 매개변수로 받아 설정하는 방식

장점
- 불변성 보장 : final 필드를 사용할 수 있어, 의존성이 반드시 주입된 상태로 객체가 생성됨
- 순환 참조 탐지 : 순환 의존성이 있을 때 어플리케이션 시작 시점에 바로 예외가 발생해 
                      문제를 조기에 파악 할 수 있음
단점
의존성이 많아지면 생성자 매개변수가 길어져 가독성이 떨어질 수 있음


세터 주입(Setter Injection)
setter메서드를 통해 의존성을 주입하는 방식

장점
의존성이 반드시 필요하지 않을 경우 setter를 통해 유연하게 주입 여부를 제어할 수 있음


<<Gradle>>
자바, 코틀린, 그루비(Groovy)등 다양한 프로그래밍 언어를 지원하는 빌드 자동화 도구
프로젝트의 전반적인 설정을  관리함
필요한 외부 라이브러리는 build.gradle에 dependencies에 추가

빌드 자동화 도구란?
소스코드로부터 실행 가능한 산출물을 생성하는 일련의 과정을 관리, 수행해 주는 도구
컴파일, 테스트, 패키징, 배포 등 개발 과정의 반복작업을 스크립트나 설정파일로 정의해 사람의 수작업없이
실행할 수 있게 해줌

Gradle의 주요 특징
1. 의존성 관리
Maven Central, JCenter, Ivy같은 의존성 저장소에서 외부 라이브러리를 쉽게 가져와 사용할 수 있도록 도와줌
이를 통해 개발자는 필요한 라이브러리를 직접 다운로드하지않고 빌드 시 자동으로 
라이브러리를 다운로드하고 관리할 수 있음

2. DSL(Domain-Specific Language)
스크립트를 작성할 때 groovy나 코틀린을 사용함
빌드 로직을 간결하고 유연하게 작성할 수 있음

3. 멀티 프로젝트 빌드
Gradle은 여러 프로젝트를 하나로 묶어 멀티 프로젝트 빌드를 지원함


<<포스트맨 API 테스트 툴>>
REST API는 크게 나눠 URL, HTTP메서드, 요청 매개변수 또는 요청 바디로 구분이 되는데,
이를 브라우저에서 테스트하는 것에는 한계가 있음

테스트를 한다고 임시로 프론트엔드 UI를 만드는 것은 지속가능한 방법은 아님

사용이 간편하고 직관적인 GUI를 제공하는 포스트맨이라는 프로그램을 사용함
설계한 API가 잘 동작하는지 확인하기 위한 툴




레이어드 아키텍처
프로그램을 기능별로 계층으로 분리하여 구조화하는 설계패턴
각 계층별 기능이 존재, 상위 계층은 하위 계층의 구현에 의존하지 않고 인터페이스를 통해서만 
상호작용 하도록 만듬

기본 개념
계층 분리
기능별로 관심사를 분리하여 모듈화함
변경이 필요한 부분은 한 계층에 국한되므로 유지보수성이 향상됨

상위 계층은 하위 계층에만 의존
하위 계층은 상위 계층에 대한 정보가 없어야 함

계층 간 직접 구현 참조를 피하고 인터페이스나 추상클래스를 통해 결합도를 낮춤


<<백엔드 서비스 아키텍처>>

레이어드 아키텍처 패턴
어플리케이션을 구성하는 요소들을 수평으로 나눠 관리하는 것

표현계층(Presentation Layer)
사용자의 요청을 받고 응답을 통해 화면을 전달하거나 데이터를 전달하는 계층
사용자(UI)와 상호작용하는 부분
Controller라고 작성

비즈니스계층(Buisness Layer)
어플리케이션의 핵심로직을 처리
트랜젝션 관리 도메인 객체간 연산, 외부 시스템 호출 조정 등
서비스의 백엔드 기능들이 들어있는 계층
비즈니스 계층을 구현하는 것은 Service라는 이름으로 클래스를 만듬

영속계층(Persistence Layer)
데이터 저장, 조회, 삭제, 수정 같은 영구 저장소와의 상호작용
SQL, ORM매핑, 트랜잭션 커밋 등
데이터베이스와 맞닿아 있는 계층 트랜잭션을 관리
영속 계층을 구현하는 클래스는 repository라고 이름을 붙힘

요청을 통해 들어오거나 응답을 통해 나가는 데이터가 존재할 것임
데이터를 담는 추상적인 개념을 Model이라고 함
데이터를 주고 받을 때 데이터를 담는 저장소
계층간의 데이터를 주고 받을 때는 DTO클래스

클라이언트 -> 컨트롤러 -> 서비스
서비스 -> 컨트롤러 -> 클라이언트

데이터베이스계층
dbms를 의미

보통 자바의 클래스 종류
기능을 수행하는 클래스, 데이터를 담기 위한 클래스
기능을 하는 클래스 : Controller, Service, Persistance

데이터를 담는 클래스 : 모델, 엔티티
model은 데이터를 담는 역할과 db의 테이블과 스키마를 표현하는 두가지 역할을 함

Entity
데이터베이스와 통신할 때 사용하는 클래스


<<DTO(Data Transition Object)>>
클라이언트가 데이터를 가지고 요청하거나, 서비스가 요청을 처리하고 클라이언트로 반환할 때, 
모델(entity)자체를 반환하는 경우는 거의 없음
보통은 데이터를 전달하기 위해 사용하는 객체인 DTO로 변환해 반환함

<<DTO로 변환해서 반환하는 이유>>
1. 비즈니스 로직의 캡슐화
- 외부인이 회사의 DB스키마를 아는 것을 원하지 않음
- 이때 DTO처럼 다른 객체로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, DB구조 등을 숨길 수 있음

2. 클라이언트가 필요한 정보를 모델이 전부 포함하지 않을 수 있음
- 에러메시지를 보내야할 때
- 어디에 담아서 보내야 하는가?
- 모델은 서비스 로직과는 관련이 없기 때문에 모델에 담는 것은 적합하지 않음
- 이런 경우 DTO에 실어서 보내는 것이 좋음


<<REST AP>>
REST(Representational State Transfer)아키텍처를 기반으로 하는 API(Application Programming Interface)

REST API는 클라이언트와 서버간의 상호작용을 HTTP를 사용해 설계한 웹 서비스 인터페이스로
데이터를 쉽게 주고받을 수 있게 해줌

REST API는 웹 어플리케이션, 모바일 앱 등 다양한 시스템 간의 통신을 위한 표준으로 널리 사용되고 있음

Rest 아키텍처 스타일은 6가지 제약 조건으로 구성됨
이 가이드를 따르는 API를 RESTful API라고 함

<<주요개념>>
클라이언트 - 서버
리소스를 관리하는 서버가 존재하고 다수의 클라이언트가 리소스를 소비하기 위해 네트워크를 통해 
서버에 접근하는 구조

Stateless
클라이언트가 서버에 요청을 보낼 때, 이전 요청의 영향을 받지 않음을 의미

일관적인 인터페이스
시스템 또는 어플리케이션의 리소스에 접근하기 위한 인터페이스가 일관적이어야 함

HTTP 메서드 사용의 일관성
GET	/users 		모든 사용자 목록 조회
GET	/users/{id}	특정 사용자를 조회
POST	/users		새로운 사용자 생성
PUT	/users/{id}	사용자 정보 업데이트
DELETE	/users{id}		사용자 삭제

API 사용자들이 다양한 리소스와 상호작용할 때 동일한 패턴을 예상할 수 있음

URI 구조의 일관성
URI경로를 일관되게 설계하는 것도 중요함
리소스의 이름은 복수형으로 일관되게 사용하고, 리소스 간 관계를 표현할 때도 규칙적으로 작성해야함

GET /users/{userId}/posts
POST /users/{userId}/posts	특정 사용자에게 새로운 게시물 생성

모든 API의 응답형식도 일관되게 설계해야 함
예를 들어 성공시 HTTP상태코드와 JSON형식의 응답을 동일하게 유지하는 것이 좋음



레이어시스템
클라이언트가 서버에 요청을 날릴 때, 여러개의 레이어로 된 서버를 거칠 수 있음
클라이언트는 여러 레이어를 인지하지 않고, 최종적으로 서버에서 오는 응답만 신경쓰면 됨
서버측에서는  각 레이어가 독립적으로 동작하며 각각의 레이어가 맡은 역할을 수행해
확장성, 보안성, 성능 최적화가 가능함


Controller
클라이언트로부터 요청을 받아오거나 서버로부터 응답을 내보내는 역할

@RestController
html같은 뷰 페이지를 반환하는 대신 JSON이나 XML형식의 데이터를 반환하는 
RESTful API를 제공하는데 적합함


@RequestMapping("주소")
해당 컨트롤러의 공통적인 부분의 주소를 갖고 있음

@GetMapping("주소")
Get으로 요청이 들어오고 주소가 맞을 때 메서드를 실행해줌

@PathVariable
- URL경로의 일부를 변수로 사용할 수 있도록 지원하는 어노테이션
- URL에 포함된 값을 동적으로 받아와 메서드의 매개변수로 사용할 수 있음
{}템플릿 변수와 매개변수의 이름이 같을 때 스프링이 요청 URL에서 값을 추출해 자동으로 변수를 채워줌
이름을다르게 쓰고 싶으면 ()에 지정하면 됨
- required 속성(필수 여부 true / false) 파라미터가 없으면 예외 발생

@RequestParam
HTTP요청이 ` 파라미터나 폼 데이터를 처리하기 위해 사용되는 어노테이션
클라이언트가 서버에 요청을 보낼 때, URL뒤에 붙이는 쿼리 스트링이나 폼 데이터를 받아서
메서드의 파라미터로 전달할 수 있게 해줌

쿼리스트링
localhost:10000/users?id=xxx&pw=xxx와 같이 key와 value로 보내는 방식

POST로 요청시 URL에 쿼리스트링이 안붙음
그래도 폼데이터를 처리하는데 사용할 수 있음

@RequestParam과 @PathVariable의 차이점
@RequestParam
주로 쿼리파라미터를 처리
또한 POST요청에 form데이터도 처리할 수 있음
@PathVariable
URL 경로의 일부로 전달되는 변수를 처리함
주로 RESTful API에서 리소스를 식별하기 위해 사용됨

@RequestBody
HTTP 요청의 본문(body)에 담긴 데이터를 자바 객체로 반환하여 컨트롤러에 있는 메서드의 매개변수로
전달하는 어노테이션
주로 POST, PUT, PATCH요청에서 사용되며 클라이언트가 전송한 JSON, XML, 또는 폼 데이터 등을
자바 객체로 변환하는 역할을 함

@ResponseBody
컨트롤러 메서드의 반환값을 HTTP응답의 본문(body)에 직접 포함시킬 때 사용됨
HTML같은 템플릿을 반환하는 대신, 주로 JSON, XML, 문자열과 같은 데이터를 클라이언트에게 반환하는데 사용


ResponseEntity
스프링에서 제공하는 클래스로 HTTP응답을 보다 세밀하게 제어할 수 있는 방법을 제공
HTTP상태 코드, 헤더, 응답 body부분을 포함한 전체 HTTP응답을 구성할 수 있으며, 주로 REST API에서 많이
사용함

주요기능
1. HTTP 상태 코드 제어
- ResponseEntity를 사용하면 클라이언트에 응답할 때 HTTP상태 코드를 명시적으로 설정할 수 있음
2. HTTP 헤더 제어
- 응답에 HTTP 헤더를 추가하거나 수정할 수 있음
- 이를 통해 캐시 제어, 인증 정보, 콘텐츠 타입을 제어할 수 있음
3. 응답 본문(body) 제어
- 응답 본문(body)에 객체나 JSON데이터를 포함할 수 있음
- 이 객체는 스프링에서 JSON 또는 XML로 직렬화 되어 클라이언트에게 반환됨 

주요 메서드
ok() : 200 OK상태코드로 응답하는 빌더 메서드
status(HttpStatus status) : 특정 상태 코드를 반환하는 메서드
noContent() : 204 No Content응답을 반환하는 메서드
badRequest() : 400 Bad Request응답을 반환하는 메서드
notFount() : 404 Not Found응답을 반환하는 메서드


서비스 레이어
표현계층과 영속 계층 사이에서 우리의 프로젝트의 기능을 담당하는 역할을 함
HTTP와 긴밀히 연결된 컨트롤러에서 분리되어 있거, 데이터베이스와 긴밀히 연관된 
리포지토리와도 분리되어 있음
따라서 서비스 레이어는 우리가 개발하고하는 로직에 집중할 수 있음


@Controller
@RestController
@Service
@Repository
@Configuration
위 어노테이션 모두 @Component의 자식 컴포넌트


영속계층
스프링 데이터 JPA
어플리케이션의 목표는 Todo 아이템은 DB에 저장해야함

관계형 데이터베이스를 자바와 연결하려면 어떻게 해야하는가?
1. DBMS를 설치해야함
2. 테이블을 생성하고 아이템을 몇 개 넣었다고 가정
- 이후에 아이템을 검색하기 위해 select쿼리를 날림
3. 쿼리를 날리면 조건에 맞는 결과가 반환됨
4. 반환된 결과를 가지고 자바 어플리케이션 내에서 사용해야 함
5. JDBC드라이버를 통해 자바와 연결함
6. Connection을 이용해 데이터베이스에 연결하고 쿼리문을 ResultSet클래스에 결과를 담아옴
7. while문 내부에서 ResultSet을 Todo객체로 바꿈
8. 테이블을 자바 내에서 사용하기 위해 Entity클래스를 만듬
- 테이블 하나마다 그에 상응하는 Entity클래스가 존재함
- 데이터를 조회, 수정, 추가, 삭제를 집중적으로 해주는 DAO클래스를 작성함
9. 시간이 흐르면서 반복작업을 줄이기 위해 Hibernate와 같은 ORM프레임워크가 나왔고,
   더 나아가 JPA같은 도구들이 개발됨



데이터베이스와 스프링 데이터 JPA설정 
- H2 데이터베이스
-->자바 기반의 경량형 관계형 데이터베이스 관리 시스템
    주로 개발 및 테스트 환경에서 사용되며, 메모리 기반 데이터베이스나 
    디스크 기반의 데이터베이스로 구성할 수 있음
H2는 오픈소스로 제공되고, 빠르고 가벼운 성능 때문에 어플리케이션 개발 시 간편하게 데이터베이스를
설정하고 사용할 수 있음


쿼리문을 사용하지 않고 JPA메서드를 이용해서 테이블에 추가하고 조회까지 해서 결과를 확인한 것

쿼리 메서드
쿼리를 직접 작성하는것이 아닌 메서드를 통해서 쿼리문을 자동으로 작성함

Spring Data JPA에서 기본적으로 제공하는 메서드
1. 저장
- save() : 엔티티를 저장하거나 이미 존재하는 엔티티를 업데이트

2. 조회
- findById : ID로 엔티티를 조회함, 반환값은 Optional
- findAll() : 모든 엔티티를 조회함

3. 삭제
- delete() : 특정 엔티티를 삭제함
- deleteById() : ID로 데이터를 삭제함

4. 카운트
- count() : 엔티티의 총 개수를 반환

5. 존재 여부 확인
- existsById() : 특정 ID가 존재하는지 확인

JPARepository인터페이스로 부터 메서드를 받아서 사용함



직접 작성하는 메서드
메서드 이름을 기반으로 자동으로 쿼리를 생성하는 기능을 제공함

기본 규칙
접두어
findBy : 주어진 조건으로 엔티티를 찾음
ex) findByName(String name); //이름으로 사용자 조회

countBy : 특정 조건을 만족하는 레코드 개수를 반환
ex) findByAge(int age);

existsBy : 특정 조건을 만족하는 레코드가 존재하는지 확인
ex) findByEmail(String email);

deleteBy : 주어진 조건에 해당되는 레코드 삭제
ex) findByDelete(String name);


2. 조건의 결합
And/Or

findByNameAndEmail(String name, String email)
findByNameOrEmail(String name, String email)

isNull/ isNotNull
null또는 null이 아닌 조건을 처리
findByEmailIsNull()
findByEmailIsNotNull()

@Query 어노테이션을 사용하여 직접 쿼리를 작성할 수 있음
JPQL이라고 하고 엔티티 객체를 대상으로 쿼리를 작성함


Todo 서비스 만들기
- 스프링과 JPA를 기반으로 생성, 검색, 수정, 삭제 API를 만듬

로그
소프트웨어 시스템이나 어플리케이션 동작 상태, 이벤트가 발생했을 때 그 내용들을 기록한 정보
개발자, 운영자 또는 시스템이 해당 어플리케이션의 상태를 파악하거나 문제 해결을 위해 사용함
주로 어플리케이션의 실행 흐름, 오류 또는 성능 문제를 추적하고 분석하는데 매우 중요한 도구

로그의 주요 목적
1. 디버깅
- 어플리케이션에서 발생한 문제나 버그를 추적하고 원인을 파악하기 위해 사용됨
2. 모니터링
- 어플리케이션이 예상대로 작동하는지 확인하고, 시스템 성능을 모니터링 하기 위해 사용됨
3. 문제해결
- 어플리케이션이 예상치 못한 상황이 발생했을 때 로그를 통해 그 문제를 해결하는데 필요한 정보를
  얻을 수 있음
4. 보안감사
- 어플리케이션에 대한 보안 감사 및 추적을 위해 사용됨
- 시스템에 대한 접근 시도나 비정상적인 활동을 로그로 기록하여 보안위협을 감지하고 대응할 수 있음

로그의 주요 구성요소
1. 타임스탬프 : 로그가 기록된 시간
2. 로그 레벨(Log level) : 로그의 중요도를 나타냄
- TRACE : 가장 낮은 수준의 로그
- DEBUG : 개발 과정에서 주로 사용되는 디버깅 정보
- INFO : 시스템의 정상적인 동작을 나타내는 정보
- WARN : 예상치 못한 상황이 발생했지만 시스템이 정상적으로 동작하는 경우
- ERROR : 오류가 발생했으며 시스템이 정상적으로 동작하지 않음
- FATAL : 매우 심각한 오류로 시스템이 더 이상 동작할 수 없는 경우
3. 메시지 : 로그에 기록된 이벤트에 대한 설명
4. 이벤트 소스 : 로그가 기록된 위치

Slf4j(Simple Logging Facade for Java)
- Java 어플리케이션에서 사용하는 로깅 프레임워크에 대한 통합된 인터페이스를 제공하는 
  로그 추상화 라이브러리

Create Todo 구현
- Todo아이템을 생성하는 기능을 구현

영속 레이어의 구현
- 엔티티를 저장하기 위해 save()메서드를 사용
- 새  Todo리스트를 반환하기 위해 findByUserId()메서드를 사용함

서비스 레이어
- Todo아이템을 생성하기 위한 비즈니스 로직을 작성
- create()메서드를 작성함

create 메서드의 구성
검증
- 넘어온 엔티티가 유효한지 검사하는 로직
- 검증하는 로직이 커지게 되면 TodoBalidator로 분리
save()
- 엔티티를 데이터베이스에 저장
- 로그를 남김
findByUserId()
- 저장된 엔티티를 포함하는 새 리스트를 반환함


수정하기 기능
Todo를 업데이트하는 기능
영속 계층
save(), findByUserId()를 사용

서비스 계층
update()메서드 작성




요청(포스트맨) -> url과 매핑되는 컨트롤러의 메서드가 실행 -> 서비스의 메서드가 실행 ->
repository의 메서드가 실행 -> db에서 결과를 가져옴 -> 서비스가 반환받음 -> 컨트롤러가 반환받음 ->
응답으로 내보냄

CORS(Cross-Origin Resource Sharing)
- 교차 출처 리소스 공유

출처(origin)
- 프로토콜과 호스트주소 그리고 포트번호를 합친것
ex) http://localhost:3000
- 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐놓은것


동일 출처 정책(Same-Origin Policy)
- 브라우저는 기본적으로 보안을 위해 동일 출처 정책이라는 규칙을 따름
- 같은 출처에서 로드된 웹사이트만 서로 데이터를 주고 받을 수 있다는 내용
- 즉 웹 페이지가 한 출처에서 로드되었을 때 다른 출처에서 데이터를 요청하는 것을 제한하는 정책
- 이 정책은 보안을 위해 악의적인 웹사이트가 사용자의 브라우저를 이용해 다른 출처에서 데이터를
  가져오지 못하게 막는 역할을 함



수정
타이틀 변경을 위해 input의 필드에서 사용자가 입력을 받아올 때 editEventHandler()에서 item을 바로
넘겨버리면 한글자씩 입력할 때마다 HTTP요청을 보내게 됨
-> 이는 비효율적이기 때문에 수정을 완료한 시점에서 HTTP 요청을 보내고 싶음
- 입력이 끝나서수정이 불가능한 상태로 바뀌는 시점


