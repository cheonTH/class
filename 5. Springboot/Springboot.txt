Servlet/JSP
우리가 만든 자바클래스를 서버쪽에서 실행
HTTP요청을 받아 동적으로 응답을 생성할 수도 있음
Servlet -> Java코드 기반 + html 얹어서 사용
JSP-> HTML기반 + Java코드를 삽입해서 동적으로 페이지를 쉽게 작성할 수 있도록 한 기술

서버 - 클라이언트 구조로 전환되어, Applet의 클라이언트 부담을 줄이고 서버에서 로직을 처리하게 됨

엔터프라이즈 자바(EJB)
- 분산, 트랜잭션, 보안 등 서버사이드 서비스를 제공하는 프레임워크
- 배우기가 어려움, 설정이 복잡하고 프로그램이 너무 무거움

Spring 프레임워크
EJB보다 가벼움, 아키텍처가 보다 유연해짐
xml, Java Config어노테이션 설정으로 확장성이 뛰어남

Spring boot
Spring에서 직접 해줘야 했던 설정들의 일부도 다 자동화가 됨
웹 서버를 내장하고 있음

백엔드는 화면이 없음 -> 콘솔을 통해서 확인, 데이터를 프론트엔드로 넘겨서 확인

포스트맨(Postman)
우리가 만든 기능을 테스트해볼 수 있는 프로그램



CSRF : 웹 어플리케이션에서 사용자가 의도치 않은 상태 변경 요청이 
공격자에 의해 자동으로 전송되도록 하는 공격 기법

start.spring.io
Group 이름은 같아도 되지만 Artifact는 달라야함
프로젝트 이름은 주로 Artifact와 비슷하게함



스프팅 부트 프로젝트의 구성
src/main/java : 서버단 java파일
test/main/java : 테스트하기위한 java파일
src/main/resources : 설정 파일 및 화면에 필요한 파일들
ㄴ> templates: html파일
ㄴ> static폴더: js, css파일
ㄴ> application.properties: 설정 코드가 들어감
build.gradle : 라이브러리 의존성 관리




@SpringBootApplication
@Configuration, @EnableAutoConfiguration, @ComponentScan 세 가지를 하나로 합친 것

@Configuration : 해당 클래스가 설정 파일임을 알려주는 용도
@EnableAutoConfiguration : 스프링의 다양한 설정이 자동으로 구성되고 완료됨
@ComponentScan : 자동으로 컴포넌트 클래스를 검색해서 컴포넌트와 빈(bean)클래스(객체)를 등록



스프링의 핵심 개념
1. Ioc(Inversion of Control, 제어역전)
객체의 생성과 관리를 개발자가 아닌 프레임워크나 컨테이너가 대신 관리하도록 하는 개념

전통적인 객체 지향 프로그래밍에서 객체 간의 의존성을 개발자가 직접 처리하는 반면
IoC는 이 흐름을 역전시켜 스프링 프레임워크와 같은 컨테이너가 객체 간의 의존성을 주입하고 관리함

IoC는 어플리케이션의 유연성과 유지보수성을 높이는데 기여하며 
스프링 프레임워크에서 가장 핵심적인 개념 중 하나

함수를 호출하는 애 -> 스프링
public User getUser(){ 
	return new User();
}
getUser() 호출했을 때 user객체를 얻을 수 있음

IoC의 주요 개념
1. 의존성 주입(Dependency Injection, DI)
- 객체를 직접 대입하는 것이 아니라 외부에서 필요한 의존성을 주입하는 방식임

2. 제어의 역전
- 전통적으로는 개발자가 직접 객체를 생성하고 관리해야하지만 
IoC에서는 객체의 생성과 생명주기를 스프링이 관리함

즉 개발자가 아니라 프레임 워크가 객체의 생명 주기를 관리하는 방식


디자인 패턴
소프트웨어 설계 과정에서 반복적으로 발생하는 문제를 해결하기 위한 재사용 가능한 설계 기법
특정 언어나 플랫폼에 종속되는 것이 아니라 상황과 해법의 구조를 문서화한 유연한 설계도라고 생각하면 됨


싱글톤 패턴
스프링이 직접 관리하도록 시킨 클래스는 메모리에 무조건 한번만 올라감
사용할 때는 메모리에 올라가 있는 객체를 받아서 사용함

팩토리 패턴
객체 생성 로직을 별도의 클래스로 분리하여 클라이언트 코드가 
구체적인 클래스에 의존하지 않도록 만드는 패턴


롬복(lombok)
어노테이션 기반의 코드 생성 라이브러리
자바 클래스에서 반복 생성되는 코드 getter, setter, 생성자, toString를 자동으로 생성해줌
- 컴파일 시점에 어노테이션이 코드를 주입하므로, 실제 소스 파일에는 메서드 구현이 보이지 않음

주요 어노테이션의 및 역할
@Getter / @Setter : 필드별 getter / setter 메서드 생성
@ToString : toString()메서드 자동 생성
@EqualsAndHashCode : equals() & hashCode()메서드 생성
@NoArgsConstructor : 파라미터 없는 생성자 생성
@AllArgsConstructor : 모든 필드를 파라미터로 받는 생성자 생성
@RequiredArgsConstructor : final 또는 @NonNull필드만 파라미터로 받는 생성자 생성
@Builder: 빌더 패턴을 지원하는 빌드 클래스를 생성 

의존성 주입(Dependency Injection)
객체가 필요한 의존 관계를 외부에서 주입해주는 설계 원칙
'제어역전'(Inversion of Control)의 한 구현 방식으로 객체 내부가 아니라 
외부 컨테이너가 객체의 생명주기와 관계를 관리함

필드 주입(Field Injection)
클래스의 필드에 @Autowired를 붙여 스프링이 직접 주입해주는 방식
setter나 생성자없이도 간단히 주입할 수 있다는 특징이 있음

장점 : 필드 선언부에 어노테이션만 붙이면 되므로 다른 코드가 거의 필요 없음

단점 : 불투명성 - 코드만 보고는 어떤 의존성이 언제 주입되는지 파악하는지 어려움
        불변성 미보장 - 초기화 전 필드가 null일 수 있음

간단히 프로토타입을 만들어볼 때 임시로 활용해볼 수 있음


생성자 주입(Consturctor Injection)
객체 생성 시점에 필요한 모든 의존성을 생성자의 매개변수로 받아 설정하는 방식

장점
- 불변성 보장 : final 필드를 사용할 수 있어, 의존성이 반드시 주입된 상태로 객체가 생성됨
- 순환 참조 탐지 : 순환 의존성이 있을 때 어플리케이션 시작 시점에 바로 예외가 발생해 
                      문제를 조기에 파악 할 수 있음
단점
의존성이 많아지면 생성자 매개변수가 길어져 가독성이 떨어질 수 있음


세터 주입(Setter Injection)
setter메서드를 통해 의존성을 주입하는 방식

장점
의존성이 반드시 필요하지 않을 경우 setter를 통해 유연하게 주입 여부를 제어할 수 있음


Gradle
자바, 코틀린, 그루비(Groovy)등 다양한 프로그래밍 언어를 지원하는 빌드 자동화 도구

빌드 자동화 도구란?
소스코드로부터 실행 가능한 산출물을 생성하는 일련의 과정을 관리, 수행해 주는 도구
컴파일, 테스트, 패키징, 배포 등 개발 과정의 반복작업을 스크립트나 설정파일로 정의해 사람의 수작업없이
실행할 수 있게 해줌

Gradle의 주요 특징
1. 의존성 관리
Maven Central, JCenter, Ivy같은 의존성 저장소에서 외부 라이브러리를 쉽게 가져와 사용할 수 있도록 도와줌
이를 통해 개발자는 필요한 라이브러리를 직접 다운로드하지않고 빌드 시 자동으로 
라이브러리를 다운로드하고 관리할 수 있음

2. DSL(Domain-Specific Language)
스크립트를 작성할 때 groovy나 코틀린을 사용함
빌드 로직을 간결하고 유연하게 작성할 수 있음

3. 멀티 프로젝트 빌드
Gradle은 여러 프로젝트를 하나로 묶어 멀티 프로젝트 빌드를 지원함


<<포스트맨 API 테스트 툴>>
REST API는 크게 나눠 URL, HTTP메서드, 요청 매개변수 또는 요청 바디로 구분이 되는데,
이를 브라우저에서 테스트하는 것에는 한계가 있음

테스트를 한다고 임시로 프론트엔드 UI를 만드는 것은 지속가능한 방법은 아님

사용이 간편하고 직관적인 GUI를 제공하는 포스트맨이라는 프로그램을 사용함


<<백엔드 서비스 아키텍처>>

레이어드 아키텍처 패턴
어플리케이션을 구성하는 요소들을 수평으로 나눠 관리하는 것

표현계층
사용자의 요청을 받고 응답으로 변환하는 계층

비즈니스계층
서비스의 백엔드 기능들이 들어있는 계층

영속계층
데이터베이스와 맞닿아 있는 계층 트랜잭션을 관리

데이터베이스계층
dbms를 의미

보통 자바의 클래스 종류
기능을 수행하는 클래스, 데이터를 담기 위한 클래스
기능을 하는 클래스 : Controller, Service, Persistance

데이터를 담는 클래스 : 모델, 엔티티
model은 데이털르 담는 역할과 db의 테이블과 스키마를 표현하는 두가지 역할을 함


<<DTO(Data Transition Object)>>
클라이언트가 데이터를 가지고 요청하거나, 서비스가 요청을 처리하고 클라이언트로 반환할 때, 
모델(entity)자체를 반환하는 경우는 거의 없음
보통은 데이터를 전달하기 위해 사용하는 객체인 DTO로 변환해 반환함

<<DTO로 변환해서 반환하는 이유>>
1. 비즈니스 로직의 캡슐화
- 외부인이 회사의 DB스키마를 아는 것을 원하지 않음
- 이때 DTO처럼 다른 객체로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, DB구조 등을 숨길 수 있음

2. 클라이언트가 필요한 정보를 모델이 전부 포함하지 않을 수 있음
- 에러메시지를 보내야할 때
- 어디에 담아서 보내야 하는가?
- 모델은 서비스 로직과는 관련이 없기 때문에 모델에 담는 것은 적합하지 않음
- 이런 경우 DTO에 실어서 보내는 것이 좋음


<<REST AP>>
REST(Representational State Transfer)아키텍처를 기반으로 하는 API(Application Programming Interface)

REST API는 클라이언트와 서버간의 상호작용을 HTTP를 사용해 설계한 웹 서비스 인터페이스로
데이터를 쉽게 주고받을 수 있게 해줌

REST API는 웹 어플리케이션, 모바일 앱 등 다양한 시스템 간의 통신을 위한 표준으로 널리 사용되고 있음

Rest 아키텍처 스타일은 6가지 제약 조건으로 구성됨
이 가이드를 따르는 API를 RESTful API라고 함

<<주요개념>>
클라이언트 - 서버
리소스를 관리하는 서버가 존재하고 다수의 클라이언트가 리소스를 소비하기 위해 네트워크를 통해 
서버에 접근하는 구조

Stateless
클라이언트가 서버에 요청을 보낼 때, 이전 요청의 영향을 받지 않음을 의미

일관적인 인터페이스
시스템 또는 어플리케이션의 리소스에 접근하기 위한 인터페이스가 일관적이어야 함

HTTP 메서드 사용의 일관성
GET	/users 		모든 사용자 목록 조회
GET	/users/{id}	특정 사용자를 조회
POST	/users		새로운 사용자 생성
PUT	/users/{id}	사용자 정보 업데이트
DELETE	/users{id}		사용자 삭제

API 사용자들이 다양한 리소스와 상호작용할 때 동일한 패턴을 예상할 수 있음

URI 구조의 일관성
URI경로를 일관되게 설계하는 것도 중요함
리소스의 이름은 복수형으로 일관되게 사용하고, 리소스 간 관계를 표현할 때도 규칙적으로 작성해야함

GET /users/{userId}/posts
POST /users/{userId}/posts	특정 사용자에게 새로운 게시물 생성

모든 API의 응답형식도 일관되게 설계해야 함
예를 들어 성공시 HTTP상태코드와 JSON형식의 응답을 동일하게 유지하는 것이 좋음



레이어시스템
클라이언트가 서버에 요청을 날릴 때, 여러개의 레이어로 된 서버를 거칠 수 있음
클라이언트는 여러 레이어를 인지하지 않고, 최종적으로 서버에서 오는 응답만 신경쓰면 됨
서버측에서는  각 레이어가 독립적으로 동작하며 각각의 레이어가 맡은 역할을 수행해
확장성, 보안성, 성능 최적화가 가능함


Controller
클라이언트로부터 요청을 받아오거나 서버로부터 응답을 내보내는 역할

@RestController
html같은 뷰 페이지를 반환하는 대신 JSON이나 XML형식의 데이터를 반환하는 
RESTful API를 제공하는데 적합함