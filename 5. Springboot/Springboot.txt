<<Servlet/JSP>>
우리가 만든 자바클래스를 서버쪽에서 실행
HTTP요청을 받아 동적으로 응답을 생성할 수도 있음
Servlet -> Java코드 기반 + html 얹어서 사용
JSP-> HTML기반 + Java코드를 삽입해서 동적으로 페이지를 쉽게 작성할 수 있도록 한 기술

서버 - 클라이언트 구조로 전환되어, Applet의 클라이언트 부담을 줄이고 서버에서 로직을 처리하게 됨

<<엔터프라이즈 자바(EJB)>>
- 분산, 트랜잭션, 보안 등 서버사이드 서비스를 제공하는 프레임워크
- 배우기가 어려움, 설정이 복잡하고 프로그램이 너무 무거움

<Spring 프레임워크>
EJB보다 가벼움, 아키텍처가 보다 유연해짐
xml, Java Config어노테이션 설정으로 확장성이 뛰어남

<Spring boot>
Spring에서 직접 해줘야 했던 설정들의 일부도 다 자동화가 됨
웹 서버를 내장하고 있음

백엔드는 화면이 없음 -> 콘솔을 통해서 확인, 데이터를 프론트엔드로 넘겨서 확인

<포스트맨(Postman)>
우리가 만든 기능을 테스트해볼 수 있는 프로그램



CSRF : 웹 어플리케이션에서 사용자가 의도치 않은 상태 변경 요청이 
공격자에 의해 자동으로 전송되도록 하는 공격 기법

start.spring.io
Group 이름은 같아도 되지만 Artifact는 달라야함
프로젝트 이름은 주로 Artifact와 비슷하게함



스프팅 부트 프로젝트의 구성
src/main/java : 서버단 java파일
test/main/java : 테스트하기위한 java파일
src/main/resources : 설정 파일 및 화면에 필요한 파일들
ㄴ> templates: html파일
ㄴ> static폴더: js, css파일
ㄴ> application.properties: 설정 코드가 들어감
build.gradle : 라이브러리 의존성 관리




@SpringBootApplication
@Configuration, @EnableAutoConfiguration, @ComponentScan 세 가지를 하나로 합친 것

@Configuration : 해당 클래스가 설정 파일임을 알려주는 용도
@EnableAutoConfiguration : 스프링의 다양한 설정이 자동으로 구성되고 완료됨
@ComponentScan : 자동으로 컴포넌트 클래스를 검색해서 컴포넌트와 빈(bean)클래스(객체)를 등록



<<스프링부트가 객체를 메모리에 올리는방법>>
Main클래스에 @SpringBootApplication어노테이션에 들어있는 @ComponentScan 어노테이션이
Main클래스가 들어있는 패키지를 모두 탐색하면서 @Component어노테이션이 붙어있는 클래스를
모두 메모리에 올림

Map형식으로 저장을 하는데 key를 클래스의 이름에서 첫글자를 소문자로 바꾸고 저장, value에 객체를 저장함
map.put("computer",new Computer());
ㄴ> 스프링을 통해서 메모리에 올라간 객체를 bean이라고 부름

스프링은 기본적으로 싱글톤 패턴을 지원함
스프링 객체 컨테이너에 한개의 객체만 생성됨
어플리케이션 전반에서 같은 bean을 공유하기 때문에 메모리를 절약하고 bean간의 상태 공유가 가능함



<<스프링의 핵심 개념>>
1. Ioc(Inversion of Control, 제어역전)
객체의 생성과 관리를 개발자가 아닌 프레임워크나 컨테이너가 대신 관리하도록 하는 개념

전통적인 객체 지향 프로그래밍에서 객체 간의 의존성을 개발자가 직접 처리하는 반면
IoC는 이 흐름을 역전시켜 스프링 프레임워크와 같은 컨테이너가 객체 간의 의존성을 주입하고 관리함

IoC는 어플리케이션의 유연성과 유지보수성을 높이는데 기여하며 
스프링 프레임워크에서 가장 핵심적인 개념 중 하나

함수를 호출하는 애 -> 스프링
public User getUser(){ 
	return new User();
}
getUser() 호출했을 때 user객체를 얻을 수 있음

IoC의 주요 개념
1. 의존성 주입(Dependency Injection, DI)
- 객체를 직접 대입하는 것이 아니라 외부에서 필요한 의존성을 주입하는 방식임

2. 제어의 역전
- 전통적으로는 개발자가 직접 객체를 생성하고 관리해야하지만 
IoC에서는 객체의 생성과 생명주기를 스프링이 관리함

즉 개발자가 아니라 프레임 워크가 객체의 생명 주기를 관리하는 방식


<디자인 패턴>
소프트웨어 설계 과정에서 반복적으로 발생하는 문제를 해결하기 위한 재사용 가능한 설계 기법
특정 언어나 플랫폼에 종속되는 것이 아니라 상황과 해법의 구조를 문서화한 유연한 설계도라고 생각하면 됨


<싱글톤 패턴>
스프링이 직접 관리하도록 시킨 클래스는 메모리에 무조건 한번만 올라감
사용할 때는 메모리에 올라가 있는 객체를 받아서 사용함

<팩토리 패턴>
객체 생성 로직을 별도의 클래스로 분리하여 클라이언트 코드가 
구체적인 클래스에 의존하지 않도록 만드는 패턴


<<롬복(lombok)>>
어노테이션 기반의 코드 생성 라이브러리
반복 생성되는 코드들을 줄이기 위해 어노테이션 형식으로 선언할 수 있게 해줌
자바 클래스에서 반복 생성되는 코드 getter, setter, 생성자, toString를 자동으로 생성해줌
- 컴파일 시점에 어노테이션이 코드를 주입하므로, 실제 소스 파일에는 메서드 구현이 보이지 않음

주요 어노테이션의 및 역할
@Getter / @Setter : 필드별 getter / setter 메서드 생성
@ToString : toString()메서드 자동 생성
@EqualsAndHashCode : equals() & hashCode()메서드 생성
@NoArgsConstructor : 파라미터 없는 생성자 생성
@AllArgsConstructor : 모든 필드를 파라미터로 받는 생성자 생성
@RequiredArgsConstructor : final 또는 @NonNull필드만 파라미터로 받는 생성자 생성
@Builder: 빌더 패턴을 지원하는 빌드 클래스를 생성 

의존성 주입(Dependency Injection)
객체가 필요한 의존 관계를 외부에서 주입해주는 설계 원칙
'제어역전'(Inversion of Control)의 한 구현 방식으로 객체 내부가 아니라 
외부 컨테이너가 객체의 생명주기와 관계를 관리함'
제어역전을 구현한 대표적인 기법

필드 주입(Field Injection)
클래스의 필드에 @Autowired를 붙여 스프링이 직접 주입해주는 방식
setter나 생성자없이도 간단히 주입할 수 있다는 특징이 있음

장점 : 필드 선언부에 어노테이션만 붙이면 되므로 다른 코드가 거의 필요 없음

단점 : 불투명성 - 코드만 보고는 어떤 의존성이 언제 주입되는지 파악하는지 어려움
        불변성 미보장 - 초기화 전 필드가 null일 수 있음

간단히 프로토타입을 만들어볼 때 임시로 활용해볼 수 있음


생성자 주입(Consturctor Injection)
객체 생성 시점에 필요한 모든 의존성을 생성자의 매개변수로 받아 설정하는 방식

장점
- 불변성 보장 : final 필드를 사용할 수 있어, 의존성이 반드시 주입된 상태로 객체가 생성됨
- 순환 참조 탐지 : 순환 의존성이 있을 때 어플리케이션 시작 시점에 바로 예외가 발생해 
                      문제를 조기에 파악 할 수 있음
단점
의존성이 많아지면 생성자 매개변수가 길어져 가독성이 떨어질 수 있음


세터 주입(Setter Injection)
setter메서드를 통해 의존성을 주입하는 방식

장점
의존성이 반드시 필요하지 않을 경우 setter를 통해 유연하게 주입 여부를 제어할 수 있음


<<Gradle>>
자바, 코틀린, 그루비(Groovy)등 다양한 프로그래밍 언어를 지원하는 빌드 자동화 도구
프로젝트의 전반적인 설정을  관리함
필요한 외부 라이브러리는 build.gradle에 dependencies에 추가

빌드 자동화 도구란?
소스코드로부터 실행 가능한 산출물을 생성하는 일련의 과정을 관리, 수행해 주는 도구
컴파일, 테스트, 패키징, 배포 등 개발 과정의 반복작업을 스크립트나 설정파일로 정의해 사람의 수작업없이
실행할 수 있게 해줌

Gradle의 주요 특징
1. 의존성 관리
Maven Central, JCenter, Ivy같은 의존성 저장소에서 외부 라이브러리를 쉽게 가져와 사용할 수 있도록 도와줌
이를 통해 개발자는 필요한 라이브러리를 직접 다운로드하지않고 빌드 시 자동으로 
라이브러리를 다운로드하고 관리할 수 있음

2. DSL(Domain-Specific Language)
스크립트를 작성할 때 groovy나 코틀린을 사용함
빌드 로직을 간결하고 유연하게 작성할 수 있음

3. 멀티 프로젝트 빌드
Gradle은 여러 프로젝트를 하나로 묶어 멀티 프로젝트 빌드를 지원함


<<포스트맨 API 테스트 툴>>
REST API는 크게 나눠 URL, HTTP메서드, 요청 매개변수 또는 요청 바디로 구분이 되는데,
이를 브라우저에서 테스트하는 것에는 한계가 있음

테스트를 한다고 임시로 프론트엔드 UI를 만드는 것은 지속가능한 방법은 아님

사용이 간편하고 직관적인 GUI를 제공하는 포스트맨이라는 프로그램을 사용함
설계한 API가 잘 동작하는지 확인하기 위한 툴




레이어드 아키텍처
프로그램을 기능별로 계층으로 분리하여 구조화하는 설계패턴
각 계층별 기능이 존재, 상위 계층은 하위 계층의 구현에 의존하지 않고 인터페이스를 통해서만 
상호작용 하도록 만듬

기본 개념
계층 분리
기능별로 관심사를 분리하여 모듈화함
변경이 필요한 부분은 한 계층에 국한되므로 유지보수성이 향상됨

상위 계층은 하위 계층에만 의존
하위 계층은 상위 계층에 대한 정보가 없어야 함

계층 간 직접 구현 참조를 피하고 인터페이스나 추상클래스를 통해 결합도를 낮춤


<<백엔드 서비스 아키텍처>>

레이어드 아키텍처 패턴
어플리케이션을 구성하는 요소들을 수평으로 나눠 관리하는 것

표현계층(Presentation Layer)
사용자의 요청을 받고 응답을 통해 화면을 전달하거나 데이터를 전달하는 계층
사용자(UI)와 상호작용하는 부분
Controller라고 작성

비즈니스계층(Buisness Layer)
어플리케이션의 핵심로직을 처리
트랜젝션 관리 도메인 객체간 연산, 외부 시스템 호출 조정 등
서비스의 백엔드 기능들이 들어있는 계층
비즈니스 계층을 구현하는 것은 Service라는 이름으로 클래스를 만듬

영속계층(Persistence Layer)
데이터 저장, 조회, 삭제, 수정 같은 영구 저장소와의 상호작용
SQL, ORM매핑, 트랜잭션 커밋 등
데이터베이스와 맞닿아 있는 계층 트랜잭션을 관리
영속 계층을 구현하는 클래스는 repository라고 이름을 붙힘

요청을 통해 들어오거나 응답을 통해 나가는 데이터가 존재할 것임
데이터를 담는 추상적인 개념을 Model이라고 함
데이터를 주고 받을 때 데이터를 담는 저장소
계층간의 데이터를 주고 받을 때는 DTO클래스

클라이언트 -> 컨트롤러 -> 서비스
서비스 -> 컨트롤러 -> 클라이언트

데이터베이스계층
dbms를 의미

보통 자바의 클래스 종류
기능을 수행하는 클래스, 데이터를 담기 위한 클래스
기능을 하는 클래스 : Controller, Service, Persistance

데이터를 담는 클래스 : 모델, 엔티티
model은 데이터를 담는 역할과 db의 테이블과 스키마를 표현하는 두가지 역할을 함

Entity
데이터베이스와 통신할 때 사용하는 클래스


<<DTO(Data Transition Object)>>
클라이언트가 데이터를 가지고 요청하거나, 서비스가 요청을 처리하고 클라이언트로 반환할 때, 
모델(entity)자체를 반환하는 경우는 거의 없음
보통은 데이터를 전달하기 위해 사용하는 객체인 DTO로 변환해 반환함

<<DTO로 변환해서 반환하는 이유>>
1. 비즈니스 로직의 캡슐화
- 외부인이 회사의 DB스키마를 아는 것을 원하지 않음
- 이때 DTO처럼 다른 객체로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, DB구조 등을 숨길 수 있음

2. 클라이언트가 필요한 정보를 모델이 전부 포함하지 않을 수 있음
- 에러메시지를 보내야할 때
- 어디에 담아서 보내야 하는가?
- 모델은 서비스 로직과는 관련이 없기 때문에 모델에 담는 것은 적합하지 않음
- 이런 경우 DTO에 실어서 보내는 것이 좋음


<<REST AP>>
REST(Representational State Transfer)아키텍처를 기반으로 하는 API(Application Programming Interface)

REST API는 클라이언트와 서버간의 상호작용을 HTTP를 사용해 설계한 웹 서비스 인터페이스로
데이터를 쉽게 주고받을 수 있게 해줌

REST API는 웹 어플리케이션, 모바일 앱 등 다양한 시스템 간의 통신을 위한 표준으로 널리 사용되고 있음

Rest 아키텍처 스타일은 6가지 제약 조건으로 구성됨
이 가이드를 따르는 API를 RESTful API라고 함

<<주요개념>>
클라이언트 - 서버
리소스를 관리하는 서버가 존재하고 다수의 클라이언트가 리소스를 소비하기 위해 네트워크를 통해 
서버에 접근하는 구조

Stateless
클라이언트가 서버에 요청을 보낼 때, 이전 요청의 영향을 받지 않음을 의미

일관적인 인터페이스
시스템 또는 어플리케이션의 리소스에 접근하기 위한 인터페이스가 일관적이어야 함

HTTP 메서드 사용의 일관성
GET	/users 		모든 사용자 목록 조회
GET	/users/{id}	특정 사용자를 조회
POST	/users		새로운 사용자 생성
PUT	/users/{id}	사용자 정보 업데이트
DELETE	/users{id}		사용자 삭제

API 사용자들이 다양한 리소스와 상호작용할 때 동일한 패턴을 예상할 수 있음

URI 구조의 일관성
URI경로를 일관되게 설계하는 것도 중요함
리소스의 이름은 복수형으로 일관되게 사용하고, 리소스 간 관계를 표현할 때도 규칙적으로 작성해야함

GET /users/{userId}/posts
POST /users/{userId}/posts	특정 사용자에게 새로운 게시물 생성

모든 API의 응답형식도 일관되게 설계해야 함
예를 들어 성공시 HTTP상태코드와 JSON형식의 응답을 동일하게 유지하는 것이 좋음



레이어시스템
클라이언트가 서버에 요청을 날릴 때, 여러개의 레이어로 된 서버를 거칠 수 있음
클라이언트는 여러 레이어를 인지하지 않고, 최종적으로 서버에서 오는 응답만 신경쓰면 됨
서버측에서는  각 레이어가 독립적으로 동작하며 각각의 레이어가 맡은 역할을 수행해
확장성, 보안성, 성능 최적화가 가능함


Controller
클라이언트로부터 요청을 받아오거나 서버로부터 응답을 내보내는 역할

@RestController
html같은 뷰 페이지를 반환하는 대신 JSON이나 XML형식의 데이터를 반환하는 
RESTful API를 제공하는데 적합함


@RequestMapping("주소")
해당 컨트롤러의 공통적인 부분의 주소를 갖고 있음

@GetMapping("주소")
Get으로 요청이 들어오고 주소가 맞을 때 메서드를 실행해줌

@PathVariable
- URL경로의 일부를 변수로 사용할 수 있도록 지원하는 어노테이션
- URL에 포함된 값을 동적으로 받아와 메서드의 매개변수로 사용할 수 있음
{}템플릿 변수와 매개변수의 이름이 같을 때 스프링이 요청 URL에서 값을 추출해 자동으로 변수를 채워줌
이름을다르게 쓰고 싶으면 ()에 지정하면 됨
- required 속성(필수 여부 true / false) 파라미터가 없으면 예외 발생

@RequestParam
HTTP요청이 ` 파라미터나 폼 데이터를 처리하기 위해 사용되는 어노테이션
클라이언트가 서버에 요청을 보낼 때, URL뒤에 붙이는 쿼리 스트링이나 폼 데이터를 받아서
메서드의 파라미터로 전달할 수 있게 해줌

쿼리스트링
localhost:10000/users?id=xxx&pw=xxx와 같이 key와 value로 보내는 방식

POST로 요청시 URL에 쿼리스트링이 안붙음
그래도 폼데이터를 처리하는데 사용할 수 있음

@RequestParam과 @PathVariable의 차이점
@RequestParam
주로 쿼리파라미터를 처리
또한 POST요청에 form데이터도 처리할 수 있음
@PathVariable
URL 경로의 일부로 전달되는 변수를 처리함
주로 RESTful API에서 리소스를 식별하기 위해 사용됨

@RequestBody
HTTP 요청의 본문(body)에 담긴 데이터를 자바 객체로 반환하여 컨트롤러에 있는 메서드의 매개변수로
전달하는 어노테이션
주로 POST, PUT, PATCH요청에서 사용되며 클라이언트가 전송한 JSON, XML, 또는 폼 데이터 등을
자바 객체로 변환하는 역할을 함

@ResponseBody
컨트롤러 메서드의 반환값을 HTTP응답의 본문(body)에 직접 포함시킬 때 사용됨
HTML같은 템플릿을 반환하는 대신, 주로 JSON, XML, 문자열과 같은 데이터를 클라이언트에게 반환하는데 사용


ResponseEntity
스프링에서 제공하는 클래스로 HTTP응답을 보다 세밀하게 제어할 수 있는 방법을 제공
HTTP상태 코드, 헤더, 응답 body부분을 포함한 전체 HTTP응답을 구성할 수 있으며, 주로 REST API에서 많이
사용함

주요기능
1. HTTP 상태 코드 제어
- ResponseEntity를 사용하면 클라이언트에 응답할 때 HTTP상태 코드를 명시적으로 설정할 수 있음
2. HTTP 헤더 제어
- 응답에 HTTP 헤더를 추가하거나 수정할 수 있음
- 이를 통해 캐시 제어, 인증 정보, 콘텐츠 타입을 제어할 수 있음
3. 응답 본문(body) 제어
- 응답 본문(body)에 객체나 JSON데이터를 포함할 수 있음
- 이 객체는 스프링에서 JSON 또는 XML로 직렬화 되어 클라이언트에게 반환됨 

주요 메서드
ok() : 200 OK상태코드로 응답하는 빌더 메서드
status(HttpStatus status) : 특정 상태 코드를 반환하는 메서드
noContent() : 204 No Content응답을 반환하는 메서드
badRequest() : 400 Bad Request응답을 반환하는 메서드
notFount() : 404 Not Found응답을 반환하는 메서드


서비스 레이어
표현계층과 영속 계층 사이에서 우리의 프로젝트의 기능을 담당하는 역할을 함
HTTP와 긴밀히 연결된 컨트롤러에서 분리되어 있거, 데이터베이스와 긴밀히 연관된 
리포지토리와도 분리되어 있음
따라서 서비스 레이어는 우리가 개발하고하는 로직에 집중할 수 있음


@Controller
@RestController
@Service
@Repository
@Configuration
위 어노테이션 모두 @Component의 자식 컴포넌트


영속계층
스프링 데이터 JPA
어플리케이션의 목표는 Todo 아이템은 DB에 저장해야함

관계형 데이터베이스를 자바와 연결하려면 어떻게 해야하는가?
1. DBMS를 설치해야함
2. 테이블을 생성하고 아이템을 몇 개 넣었다고 가정
- 이후에 아이템을 검색하기 위해 select쿼리를 날림
3. 쿼리를 날리면 조건에 맞는 결과가 반환됨
4. 반환된 결과를 가지고 자바 어플리케이션 내에서 사용해야 함
5. JDBC드라이버를 통해 자바와 연결함
6. Connection을 이용해 데이터베이스에 연결하고 쿼리문을 ResultSet클래스에 결과를 담아옴
7. while문 내부에서 ResultSet을 Todo객체로 바꿈
8. 테이블을 자바 내에서 사용하기 위해 Entity클래스를 만듬
- 테이블 하나마다 그에 상응하는 Entity클래스가 존재함
- 데이터를 조회, 수정, 추가, 삭제를 집중적으로 해주는 DAO클래스를 작성함
9. 시간이 흐르면서 반복작업을 줄이기 위해 Hibernate와 같은 ORM프레임워크가 나왔고,
   더 나아가 JPA같은 도구들이 개발됨



데이터베이스와 스프링 데이터 JPA설정 
- H2 데이터베이스
-->자바 기반의 경량형 관계형 데이터베이스 관리 시스템
    주로 개발 및 테스트 환경에서 사용되며, 메모리 기반 데이터베이스나 
    디스크 기반의 데이터베이스로 구성할 수 있음
H2는 오픈소스로 제공되고, 빠르고 가벼운 성능 때문에 어플리케이션 개발 시 간편하게 데이터베이스를
설정하고 사용할 수 있음


쿼리문을 사용하지 않고 JPA메서드를 이용해서 테이블에 추가하고 조회까지 해서 결과를 확인한 것

쿼리 메서드
쿼리를 직접 작성하는것이 아닌 메서드를 통해서 쿼리문을 자동으로 작성함

Spring Data JPA에서 기본적으로 제공하는 메서드
1. 저장
- save() : 엔티티를 저장하거나 이미 존재하는 엔티티를 업데이트

2. 조회
- findById : ID로 엔티티를 조회함, 반환값은 Optional
- findAll() : 모든 엔티티를 조회함

3. 삭제
- delete() : 특정 엔티티를 삭제함
- deleteById() : ID로 데이터를 삭제함

4. 카운트
- count() : 엔티티의 총 개수를 반환

5. 존재 여부 확인
- existsById() : 특정 ID가 존재하는지 확인

JPARepository인터페이스로 부터 메서드를 받아서 사용함



직접 작성하는 메서드
메서드 이름을 기반으로 자동으로 쿼리를 생성하는 기능을 제공함

기본 규칙
접두어
findBy : 주어진 조건으로 엔티티를 찾음
ex) findByName(String name); //이름으로 사용자 조회

countBy : 특정 조건을 만족하는 레코드 개수를 반환
ex) findByAge(int age);

existsBy : 특정 조건을 만족하는 레코드가 존재하는지 확인
ex) findByEmail(String email);

deleteBy : 주어진 조건에 해당되는 레코드 삭제
ex) findByDelete(String name);


2. 조건의 결합
And/Or

findByNameAndEmail(String name, String email)
findByNameOrEmail(String name, String email)

isNull/ isNotNull
null또는 null이 아닌 조건을 처리
findByEmailIsNull()
findByEmailIsNotNull()

@Query 어노테이션을 사용하여 직접 쿼리를 작성할 수 있음
JPQL이라고 하고 엔티티 객체를 대상으로 쿼리를 작성함


Todo 서비스 만들기
- 스프링과 JPA를 기반으로 생성, 검색, 수정, 삭제 API를 만듬

로그
소프트웨어 시스템이나 어플리케이션 동작 상태, 이벤트가 발생했을 때 그 내용들을 기록한 정보
개발자, 운영자 또는 시스템이 해당 어플리케이션의 상태를 파악하거나 문제 해결을 위해 사용함
주로 어플리케이션의 실행 흐름, 오류 또는 성능 문제를 추적하고 분석하는데 매우 중요한 도구

로그의 주요 목적
1. 디버깅
- 어플리케이션에서 발생한 문제나 버그를 추적하고 원인을 파악하기 위해 사용됨
2. 모니터링
- 어플리케이션이 예상대로 작동하는지 확인하고, 시스템 성능을 모니터링 하기 위해 사용됨
3. 문제해결
- 어플리케이션이 예상치 못한 상황이 발생했을 때 로그를 통해 그 문제를 해결하는데 필요한 정보를
  얻을 수 있음
4. 보안감사
- 어플리케이션에 대한 보안 감사 및 추적을 위해 사용됨
- 시스템에 대한 접근 시도나 비정상적인 활동을 로그로 기록하여 보안위협을 감지하고 대응할 수 있음

로그의 주요 구성요소
1. 타임스탬프 : 로그가 기록된 시간
2. 로그 레벨(Log level) : 로그의 중요도를 나타냄
- TRACE : 가장 낮은 수준의 로그
- DEBUG : 개발 과정에서 주로 사용되는 디버깅 정보
- INFO : 시스템의 정상적인 동작을 나타내는 정보
- WARN : 예상치 못한 상황이 발생했지만 시스템이 정상적으로 동작하는 경우
- ERROR : 오류가 발생했으며 시스템이 정상적으로 동작하지 않음
- FATAL : 매우 심각한 오류로 시스템이 더 이상 동작할 수 없는 경우
3. 메시지 : 로그에 기록된 이벤트에 대한 설명
4. 이벤트 소스 : 로그가 기록된 위치

Slf4j(Simple Logging Facade for Java)
- Java 어플리케이션에서 사용하는 로깅 프레임워크에 대한 통합된 인터페이스를 제공하는 
  로그 추상화 라이브러리

Create Todo 구현
- Todo아이템을 생성하는 기능을 구현

영속 레이어의 구현
- 엔티티를 저장하기 위해 save()메서드를 사용
- 새  Todo리스트를 반환하기 위해 findByUserId()메서드를 사용함

서비스 레이어
- Todo아이템을 생성하기 위한 비즈니스 로직을 작성
- create()메서드를 작성함

create 메서드의 구성
검증
- 넘어온 엔티티가 유효한지 검사하는 로직
- 검증하는 로직이 커지게 되면 TodoBalidator로 분리
save()
- 엔티티를 데이터베이스에 저장
- 로그를 남김
findByUserId()
- 저장된 엔티티를 포함하는 새 리스트를 반환함


수정하기 기능
Todo를 업데이트하는 기능
영속 계층
save(), findByUserId()를 사용

서비스 계층
update()메서드 작성




요청(포스트맨) -> url과 매핑되는 컨트롤러의 메서드가 실행 -> 서비스의 메서드가 실행 ->
repository의 메서드가 실행 -> db에서 결과를 가져옴 -> 서비스가 반환받음 -> 컨트롤러가 반환받음 ->
응답으로 내보냄

CORS(Cross-Origin Resource Sharing)
- 교차 출처 리소스 공유

출처(origin)
- 프로토콜과 호스트주소 그리고 포트번호를 합친것
ex) http://localhost:3000
- 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐놓은것


동일 출처 정책(Same-Origin Policy)
- 브라우저는 기본적으로 보안을 위해 동일 출처 정책이라는 규칙을 따름
- 같은 출처에서 로드된 웹사이트만 서로 데이터를 주고 받을 수 있다는 내용
- 즉 웹 페이지가 한 출처에서 로드되었을 때 다른 출처에서 데이터를 요청하는 것을 제한하는 정책
- 이 정책은 보안을 위해 악의적인 웹사이트가 사용자의 브라우저를 이용해 다른 출처에서 데이터를
  가져오지 못하게 막는 역할을 함



수정
타이틀 변경을 위해 input의 필드에서 사용자가 입력을 받아올 때 editEventHandler()에서 item을 바로
넘겨버리면 한글자씩 입력할 때마다 HTTP요청을 보내게 됨
-> 이는 비효율적이기 때문에 수정을 완료한 시점에서 HTTP 요청을 보내고 싶음
- 입력이 끝나서수정이 불가능한 상태로 바뀌는 시점


--------------------------------------------------------------------------------------
리액트
사용자가 이용하는 인터페이스
추가, 조회, 수정, 삭제

비동기 AJAX(Asynchronous JavaScript And XML)
페이지를 새로고침하지 않고 백그라운드에서 서버와 통신하는 기술
Fetch API, Axios를 이용한 비동기 요청을 AJAX호출이라고 부름

Fetch API
내장된 표준 HTTP클라이언트 API
네트워크 요청을 보내고 Promise로 응답을 처리하게 해줌
추가 라이브러리 없이 바로 사용할 수 있음

Axios
자바스크립트로 작성된 외부 HTTP클라이언트 라이브러리
브라우저 뿐 아니라 Node.js환경에서도 동일한 코드로 사용할 수 있음
요청, 응답, 인터셉터, 자동 JSON변환 타임아웃 설정 등 부가 기능을 제공함

요청, 응답, 인터셉터
서버와 통신하기 전, 후 공통 로직 처리를 삽입할 수 있게 해주는 기능
모든 요청에 토큰(로그인하면 토큰 발급 등...)을 자동으로 붙이거나 에러 응답을 일괄처리할 때 유용함


URL에 따라서 controller까지 들어오는 과정
스프링부트는 결국 스프링을 기반으로 만들어진 프레임워크
스프링에서는 기본적인 설정들을 어느정도 해줬어야 했음

---------------------------------------------------------------------------------------


프로젝트 만들 때 요령
1. 패키지를 먼저 만듬(dto, model, service, controller, repository)
2. Entity부터 만들기(DB의 테이블과 1대1 매핑)
3. DTO만들기
4. Controller만들기
5. Service만들기
6. Repository만들기


추가 @PostMapping

조회 @GetMapping
ㄴ 전체조회
ㄴ 하나만 조회
ㄴ 범위에 대한 조회

수정 @PutMapping

삭제 @DeleteMapping



인증
- 사용자가 누구인지 확인하는 과정
- 사용자가 제공한 정보(이름과 비밀번호)를 바탕으로, 시스템이 해당 사용자가 누구인지 확인하는 단계

방법
- 사용자명과 비밀번호
ㄴ> 가장 전통적인 방식의 인증방식, 사용자가 입력한 비밀번호와 저장된 비밀번호를 비교하여 신원을 확인함
- 다중 요소 인증(MFA)
ㄴ> 비밀번호 외에도 추가적인 인증수단(SMS코드,  이메일 확인 등)을 사용하여 보안을 강화함
- 생체인증
ㄴ> 지문, 안면 인식 등 사용자의 고유한 생체정보를 이용한 인증 방식
- OAuto2.0 소셜로그인
ㄴ> 사용자가 페이스북, 구글과 같은 외부 서비스의 계정을 이용해 로그인하는 방식


인가
- 사용자가 인증된 후, 그 사용자가 무엇을 할 수 있는지를 결정하는 과정
- 특정 자원이나 기능에 접근할 수 있는 권한을 부여하는 절차
- 사용자에게 주어진 역할(Role)과 권한(Authority)에 따라 리소스에 대한 접근 권한을 부여함

동작 과정
사용자가 인증된 후, 시스템은 사용자의 역할, 권한 등을 바탕으로 사용자가 어떤 자원에 접근할 수 있고, 
어떤 작업을 수행할 수 있는지를 결정함

방법
- 역할 기반 인가(RBAC, Role-Based Access Control)
ㄴ> 사용자는 특정역할(관리자, 사용자, 게스트 등)에 속하며 각 역할에 따라 다른 권한이 부여됨

- 정책 기반 인가(PBAC, Policy-Based Access Control)
ㄴ> 미리 설정된 정책에 따라 사용자의 권한이 결정됨

- 권한 기반 인가
ㄴ> 특정 권한(읽기, 쓰기, 삭제 등)에 따라 자원 접근 여부를 결정함


필터 기반 아키텍처
- 스프링 시큐리티는 필터 체인 기반으로 동작
- HTTP요청이 들어오면 여러 보안 필터들이 순차적으로 실행되어 요청을 처리하고, 보안 관련 로직을 적용함

스프링 시큐리티와 서블릿 필터
- API가 실행될 때마다 기능이 실행되기 전 사용자 인증을 해야함
- 필터가 HTTP요청과 응답을 가로채 요청이 컨트롤러에 도달하기 전 또는 응답이 클라이언트에게 전달되기 전
  필요한 전처리, 후처리를 수행하는 데 사용됨
- 주로 보안, 로그기록(로깅), 인코딩 설정, 데이터 압축 등의 작업을 처리할 때 유용함
- 서블릿 필터를 구현하고, 서블릿 필터를 서블릿 컨테이너가 실행하도록 설정만 해주면 됨 

Basic 인증
http요청에 아이디와 비밀번호를 같이 보냄

동작 방식
1. 클라이언트가 요청을 보냄
2. 서버가 인증을 요구함
3. 클라이언트가 자격증명을 전송(아이디와 비밀번호를 암호화)
4. 서버가 인증 확인(복호화해서 확인)
5. 유저 정보가 저장된 데이터베이스 또는 인증 서버의 데이터와 비교
6. 정보가 일치하면 요청받은 일을 수행

장점
1. 단순하고 구현이 쉬움
2. HTTP표준이라 모든 HTTP클라이언트에서 쉽게 지원됨

단점
1. 보안 취약점
ㄴ> 사용자 이름과 비밀번호가 쉽게 노출될 수 있음
2. HTTPS가 필수
3. 세션관리가 어려움
ㄴ> 연결상태를 유지하지 않기 때문에 매 요청마다 인증정보를 함께 전송해야함


토큰 기반 인증
사용자가 인증에 성공한 후 토큰을 발급받아, 이를 서버와의 통신에서 인증을 처리하는 방식
이 방식은 세션 기반 인증과 달리, 서버에 이용자의 상태를 저장하지 않고 토큰을 통해 인증을 관리하기 때문에
무상태 방식으로 작동함

토큰
서버가 사용자를 구별할 수 있는 문자열

Basic인증과 다른점은 아이디와 비밀번호를 매번 네트워크에 전송해야할 필요가 없어 
보안 측면에서 조금 더 안전함

토큰은 서버가 마음대로 생성할 수 있으므로 사용자의 인가 정보 또는 유효기간을 다르게 정하거나
임의로 로그아웃 할 수도 있음

JSON웹 토큰 (JWT, JSON WEB TOKEN)
- JSON 형식으로 사용자 정보를 저장하고 서명(Signature)을 통해 토큰의 무결성을 검증하는 
  토큰 기반 인증방식
- JWT는 무상태(Stateless)방식으로, 서버가 사용자 정보를 별도로 저장하지 않고
  클라이언트를 인증할 수 있기 때문에 분산 시스템이나 RESTful API에서 많이 사용됨

서명(Signature)
서명하고 싶은 메시지를 해시함수를 이용해 축약한 후 개인키로 암호화 했을 때 나오는 결과값

해시함수
임의의 길이의 데이터를 고정길이의 값으로 변환하는 함수

개인키
암호화된 데이터의 복호화, 전자서명 생성 등에 사용되며 절대 노출되면 안되는 값


JWT의 구성
- Header부분
ㄴ> 토큰의 타입, 서명 알고리즘을 포함함
ㄴ> 토큰의 타입 : JWT, 해싱 알고리즘 : HS256

- Payload부분
ㄴ> 토큰에 담을 실제 정보
ㄴ> 사용자ID, 토큰 발행 주체, 토큰의 만료시간, 토큰 발행시간

- Signature부분
ㄴ> Header부분, Payload부분을 Base64로 인코딩한 뒤 문자열을 선택한 알고리즘(hash256)과 개인키로 
     암호화하여 생성함

해싱함수
임의의 길이 데이터를 고정길이의 데이터로 만들어주는 함수
SHA-256 해싱함수는 무조건 256비트로 바꿈(32바이트)


Base64
이진데이터를 텍스트 문자 집합(ASCII)로 안전하게 저장하기 위해 6비트씩 끊어 
64가지 문자(영어 대소문자, 숫자, +, /)로 인코딩하는 방식



HandlerMapping : 요청 URL -> 어떤 컨트롤러의 메서드가 이 요청을 처리할 것인가를 결정하는 객체

HandlerAdapter : Mapping에서 골라준 메서드를 실행하고 결과를 받아오는 객체


스프링 시큐리티
스피링 기반 어플리케이션에서 인증(Authentication)과 인가(Authorization)를 처리하기 위한 보안 프레임워크
스프링 어플리케이션에서 보안과 관련된 다양한 요구사항을 손쉽게 구현할 수 있도록 도움



백엔드로 데이터를 전달하는 방법
백엔드로 요청을 할 때는 항상 axios, fetch를 사용함
요청 url에 적으면 됨

1. @PathVariable
ㄴ> 주소의 일부를 변수로 받음
ㄴ> Ex) http:// ... /products/tv/1
ㄴ> Ex) @GetMapping("tv/{id}) 	public Stirng getId(@PathVariable int id){ ... }
ㄴ> RESTful API설계에서 리소스 식별자를 표현할 때 적합함
ㄴ> 필수로 전달해야 하는 값

2. @RequestParam
ㄴ> 쿼리스트링으로 넘어오는 데이터를 매개변수에 전달
ㄴ> 쿼리스트링 : URL에서 ?뒤에 붙는 추가 정보
      주로 키=값 쌍으로 구성되며 여러개일때는 &로 구분함
      웹 서버나 어플리케이션에 매개변수를 전달 할 때 자주 사용함
ㄴ> Ex) http:// ... /products?id=1&name=tv&brand=LG
ㄴ> 선택적 필터링이나 정렬, 페이징처리에 적합함
ㄴ> required = false설정으로 선택적으로 파라미터를 받을 수 있음
     기본값 제공이나 옵션처리에 용이함


POST로 데이터를 전달할 때는 body에 실어 보냄
URL에 리소스가 있다면 @PathVariable로 받을 수 있음
하지만 쿼리스트링으로 데이터가 전달되지는 않음

리액트에서 스프링부트로 데이터를 전달할 때 JSON으로 보냄
{"키":"값"} -> JSON
{"id" : 1, "email" : "one@korea.com"}
전달된 데이터를 매개변수에 넣을 때 @RequestBody를 써야함
@PostMapping("/users")
public ~~ users(@RequestBody UserDTO dto){ ... }

직렬화
자바 객체를 JSON문자열로 변환하는 과정
네트워크 전송, 파일 저장 등 바이트 스트림이나 텍스트형태로 객체를 외부로 내보낼 때 사용
@ResponseBody -> 직렬화 할때 사용

역직렬화
JSON문자열을 자바 객체로 변환하는 과정
외부에서 전달받은 JSON데이터를 자바 객체로 복원할 때 사용
@RequestBody -> 역직렬화 할때 사용



클라이언트와 서버간의 데이터를 주고 받을 때는 DTO에 넣음
서버에서 JPA에 데이터를 전달할 때 만큼은 Entity여야 함
ㄴ DTO에서 Entity로 변경하는 시점은 controller나 service 어느곳에서 해도 상관은 없음
    대신 일관성 있게 한곳에서만 하는 것이 좋음

Entity : 테이블과 1대1로 매핑되는 클래스
Entity의 필드는 테이블의 열과 일치해야 함
Entity로 데이터를 주고받게 되면 혹여나 내 데이터베이스 스키마가 노출될 수도 있음
예민한 정보들을 빼고 전달할 수 있는 DTO클래스를 만들어서 주고 받음

DTO(Data Transfer Object)



http의 특성
무상태성(stateless) : 서버가 클라이언트의 이전 요청 상태를 보존하지 않는 특성을 말함
ㄴ 요청에 필요한 모든 정보(인증정보, 파라미터)는 매번 포함되어야 하며 
    서버는 별도로 세션상태를 조회하지 않음

무상태성을 보완하기 위한 기법
1. 쿠키(Cookie)
- 서버가 응답에 쿠키를 보내 저장함
- 이후 요청시 쿠키가 헤더에 담겨 넘어옴
2. 세션
- 서버가 메모리나 데이터베이스에 세션정보를 저장
- 클라이언트에게 세션 ID만 전달함
- 클라이언트는 매 요청시 세션 ID를 보내고, 서버는 ID로 세션 상태를 조회하여 연속성을 유지
3. 토큰 기반 인증(Token-based Auth)
- JWT같은 토큰을 발급해 클라이언트에 저장함
- 클라이언트는 Authorization : Bearer '토큰값' 헤더에 토큰을 담아 요청하며, 서버는 토큰을 검증해
   사용자 정보를 얻음

아이디와 비밀번호를 통해서 인증이 완료가 되면 토큰을 발급해 줌

1. 사용자가 우리의 todo기능을 사용하려고 할 때 토큰을 요청에 같이 실어서 보냄

2. 기능이 실행되기 전에 토큰이 유효한지 검증해야함
ㄴ 기능마다 검증하는 코드를 만들어도 상관은 없음
ㄴ 기능이 많아지게 되면 직접 검증하는 코드를 만드는 것은 비효율적임

3. 필터
클라이언트의 요청이 컨트롤러에 도달하기 전 또는 응답으로 나가기 전에 가로채서 추가 작업을 수행하는 것

커스텀 필터를 제작
Filter클래스
여러번 실행될 수 있음
init(), doFilter(), destory()메서드가 존재함

OncePerRequestFilter 클래스
스프링이 제공하는 추상클래스
같은 요청에 대해서 한 번만 실행이 되도록 보장
내부적으로 이미 실행된 요청인지 판단해서 중복 실행을 막음
doFilterInternal()만 구현하면 됨


CSRF
사용자가 이미 로그인한 웹사이트(A)의 세션 쿠키를 가진 상태에서 공격자가 만든 악성페이지를 열도록 
유도하면 B페이지에서 A서버로 사용자 권한으로 위조된 요청을 보낼수도 있음

disabled() : REST API처럼 세션을 사용하지 않거나, 클라이언트가 토큰을 처리하기 어려운 경우
	   보호 기능을 끌 수 있음


프론트엔드 통합
프론트 엔드 어플리케이션은 이제부터 백엔드 HTTP요청을 보낼 때 403이 날라오면 토큰을 어디가에
저장해놓고 로그인페이지로 다이렉트 해야함
저장해놓은 토큰을 HTTP요청을 보낼때 마다 헤더에 Bearer토큰으로 지정해줘야 함
접근 거부시 로그인페이지로 라우팅
http://localhost:10000/todo에 요청했을 때 거부당할 수 있음
App.js의 useEffect 또는 add, delete, update를 보면 API콜을 위해 ApiService의 call메서드를 사용하는 것을 
알 수 있음
HTTP메서드의 종류에 상관없이 로그인하지 않을 경우 로그인페이지로 리다이렉트 해야함



클라우드 컴퓨팅 서비스
- 인터넷을 통해 서버, 저장공간, 데이터베이스, 네트워크 소프트웨어를 제공하는 서비스
- 예전에는 컴퓨테에 필요한 프로그램이나 파일을 직접 설치하고 저장해야 했지만
  클라우드를 통해 인터넷만 있으면 어디에서나 데이터를 저장하거나 프로그램을 사용할 수 있음

클라우드 컴퓨팅 서비스의 종류
1. laaS(Infrastructure  as a Service)
- 서버, 네트워크, 저장공간 같은 기본적인 컴퓨터 자원을 인터넷을 통해 빌려주는 서비스
- 사용자가 필요한 서버를 빌리고 그 위에 운영체제를 설치하거나 설정할 수 있음
- 서버를 물리적으로 사지 않고 빌려서 사용하므로 비용이 절감됨
2. Paas(Platform as a Service)
- 플랫폼만 제공하는 서비스
- 개발자가 어플리케이션을 쉽게 개발하고 배포할 수 있도록 도와줌
- 서버 설정, 네트워크 관리 등을 신경쓰지 않고 개발에만 집중할 수 있음
3. SaaS(Software as a Service)
- 인터넷을 통해 소프트웨어를 제공하는 서비스
- 구글 스프레드 시트, 웹 하드
- 소프트웨어를 다운로드 하지 않고, 웹 브라우저를 바로 사용할 수 있음

클라우드 컴퓨팅의 장점
- 비용절감 : 필요한 만큼만 자원을 빌려 쓸 수 있기 때문에 물리적인 장비를 사지 않아도 됨
- 확장성 : 사용량에 따라 자원을 쉽게 늘리거나 줄일 수 있음
- 접근성 : 인터넷만 있으면 언제 어디서든 데이터를 저장하고 프로그램을 사용할 수 있음
- 안정성 : 클라우드는 데이터를 안전하게 보관하고 백업해주는 기능이 있어 데이터를 잃어버릴 위험이 줄어듬

클라우드 컴퓨팅 서비스가 중요한 이유
- 데이터를 클라우드에 저장하면 컴퓨터나  스마트폰에 문제가 생겨도 데이터를 잃어버리지 않음
- 기업들은 더 많은 컴퓨터와 서버를 직접 관리할 필요 없이 클라우드를 통해 손 쉽게 자원을 관리할 수 있음
- 언제 어디서나 파일에 접근하고 작업할 수 있음